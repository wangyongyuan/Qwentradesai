# 05-市场检测器模块

## 目录
1. [概述和设计理念](#1-概述和设计理念)
2. [层级过滤模型架构](#2-层级过滤模型架构)
3. [环境层详细说明](#3-环境层详细说明)
4. [触发层详细说明](#4-触发层详细说明)
5. [确认层详细说明](#5-确认层详细说明)
6. [配置参数、数据流和使用说明](#6-配置参数数据流和使用说明)

---

## 1. 概述和设计理念

### 1.1 模块定位

市场检测器（Market Detector）是系统的核心交易信号生成模块，负责基于技术指标和市场数据自动识别交易机会。该模块采用**层级过滤模型（Hierarchical Filter Model）**，通过三层过滤机制确保信号质量，避免假信号和过度交易。

**核心功能：**
- 自动检测市场交易机会
- 生成高质量的交易信号
- 提供信号强度分级和置信度评分
- 完整记录检测过程，支持回溯分析

**触发时机：**
- 每15分钟自动触发（15m K线更新时）
- 仅在ETH币种上运行（可扩展至其他币种）

### 1.2 设计原则

#### 1.2.1 层级过滤原则

**串行过滤机制：**
- 信号必须依次通过**环境层 → 触发层 → 确认层**
- 任何一层不通过即被过滤，不生成信号
- 每层职责单一，逻辑清晰，易于理解和调试

**层级职责划分：**
- **环境层**：判断市场方向和活跃度，过滤不适合交易的市场状态
- **触发层**：在确定的方向上寻找具体的入场时机
- **确认层**：验证信号的真实性，确保是真金白银的突破

**优势：**
- 避免复杂的权重计算和参数依赖
- 每层都有明确的过滤目的，职责单一
- 逻辑清晰，易于调试和优化

#### 1.2.2 避免的问题

**1. OR逻辑陷阱**
- **问题**：使用"任一指标触发即可"的逻辑会导致大量假信号
- **原因**：不同指标在不同市场环境下有效性不同，趋势指标和均值回归指标互相矛盾
- **解决**：采用层级过滤，先确定市场环境，再在该环境下寻找信号

**2. 参数依赖**
- **问题**：加权投票模型需要大量回测数据才能确定合理的权重参数
- **原因**：权重参数（如EMA权重0.25，RSI权重0.1）缺乏统计学依据
- **解决**：使用逻辑过滤而非权重计算，不依赖需要大量数据才能确定的参数

**3. 状态滞后**
- **问题**：使用ADX等滞后指标判断市场状态，等确认时可能已错过最佳入场点
- **原因**：ADX需要多个周期才能确认趋势，存在滞后性
- **解决**：使用价格行为（Price Action），价格相对于EMA的位置是即时的

#### 1.2.3 核心优势

**1. 方向性过滤**
- 环境层确定市场方向（BULL/BEAR）后，只在该方向寻找信号
- 避免逆势交易，减少假信号
- 在牛市忽略超买信号，在熊市忽略超卖信号

**2. 动态阈值**
- 成交量确认使用统计学方法：`阈值 = 平均值 + 1.5 × 标准差`
- 而非固定倍数（如2倍），适应不同市场环境
- 在低波动时期也能正常检测

**3. 多时间框架共振**
- 15m和4h趋势对齐时，信号强度会提升
- 减少假突破，提高信号可靠性
- 短期和中期趋势一致时，成功率更高

**4. 完整追溯性**
- 所有检测过程（无论是否生成信号）都保存快照
- 通过`snapshot_id`关联信号和检测快照
- 支持回溯分析、参数优化、策略改进

### 1.3 技术架构

#### 1.3.1 模块结构

```
市场检测器 (MarketDetector)
├── 数据获取层
│   └── _get_klines() - 获取K线数据（含技术指标）
│       ├── 15m K线（默认100根）
│       ├── 4h K线（默认60根）
│       └── 1d K线（可选，40根）
│
├── 环境层 (Filter Layer)
│   └── _filter_layer() - 判断市场模式和活跃度
│       ├── 市场模式判断（BULL/BEAR/NEUTRAL）
│       ├── 市场活跃度判断（布林带宽度）
│       └── 多时间框架对齐判断
│
├── 触发层 (Trigger Layer)
│   ├── _check_momentum_turn() - MACD动量转折
│   ├── _check_ema_cross() - EMA交叉
│   ├── _check_rsi_extreme() - RSI极值
│   ├── _check_bb_breakout() - 布林带突破
│   ├── _check_volume_surge() - 成交量异常
│   └── _check_price_pattern() - 价格形态（吞没）
│
├── 确认层 (Confirmation Layer)
│   └── _confirmation_layer() - 成交量和布林带确认
│       ├── 成交量确认（动态阈值）
│       └── 布林带确认（宽度扩大）
│
├── 信号生成层
│   ├── _calculate_signal_strength() - 计算信号强度
│   ├── _save_snapshot() - 保存检测快照
│   └── _save_signal() - 保存交易信号
│
└── 主入口
    └── detect() - 执行完整检测流程
```

#### 1.3.2 数据依赖

**输入数据：**
- K线数据（OHLCV）
- 技术指标：
  - EMA（9, 21, 55）
  - RSI（7, 14）
  - MACD（线、信号线、柱状图）
  - 布林带（上轨、中轨、下轨、宽度）
  - OBV（能量潮指标）

**输出数据：**
- `market_detection_snapshots`：检测快照（每次检测都保存）
- `market_signals`：交易信号（仅通过所有层级的信号）

### 1.4 数据表设计

#### 1.4.1 market_detection_snapshots（检测快照表）

**表用途：**
存储每次检测的完整信息，无论是否生成信号都保存。用于回溯分析、参数优化、策略改进。

**关键字段说明：**

| 字段 | 类型 | 说明 |
|------|------|------|
| `symbol` | VARCHAR(20) | 币种名称（BTC, ETH等） |
| `detected_at` | TIMESTAMPTZ | 检测时间（UTC时区） |
| `price` | DECIMAL(20,8) | 检测时的价格 |
| `market_mode` | VARCHAR(20) | 市场模式：BULL/BEAR/NEUTRAL |
| `market_active` | BOOLEAN | 市场是否活跃 |
| `trend_15m` | BOOLEAN | 15m趋势方向（True=上涨） |
| `trend_4h` | BOOLEAN | 4h趋势方向 |
| `multi_tf_aligned` | BOOLEAN | 多时间框架是否对齐 |
| `momentum_turn` | BOOLEAN | MACD动量转折 |
| `ema_cross` | BOOLEAN | EMA交叉 |
| `rsi_extreme` | BOOLEAN | RSI极值 |
| `bb_breakout` | BOOLEAN | 布林带突破 |
| `volume_surge` | BOOLEAN | 成交量异常 |
| `price_pattern` | BOOLEAN | 价格形态（吞没） |
| `rsi_value` | DECIMAL(10,4) | 当前RSI值 |
| `macd_histogram` | DECIMAL(20,8) | MACD柱状图值 |
| `volume_ratio` | DECIMAL(10,4) | 成交量比率（当前/平均） |
| `bb_width_ratio` | DECIMAL(10,4) | 布林带宽度比率（当前/平均） |
| `volume_confirm` | BOOLEAN | 成交量确认 |
| `bb_confirm` | BOOLEAN | 布林带确认 |
| `has_signal` | BOOLEAN | 是否生成信号 |
| `signal_direction` | VARCHAR(10) | 信号方向：LONG/SHORT/NONE |
| `signal_strength` | VARCHAR(20) | 信号强度：WEAK/MODERATE/STRONG/VERY_STRONG |
| `position_size_multiplier` | DECIMAL(5,2) | 仓位倍数（1.0=正常，2.0=加倍） |
| `kline_15m_count` | INTEGER | 使用的15m K线数量 |
| `kline_4h_count` | INTEGER | 使用的4h K线数量 |
| `kline_1d_count` | INTEGER | 使用的1d K线数量（可选） |
| `detection_version` | VARCHAR(20) | 检测算法版本（默认1.0） |

**索引设计：**
- `idx_detection_snapshot_symbol`：按币种查询
- `idx_detection_snapshot_time`：按时间查询
- `idx_detection_snapshot_symbol_time`：按币种和时间联合查询
- `idx_detection_snapshot_has_signal`：查询有信号的快照
- `idx_detection_snapshot_strength`：按信号强度查询

#### 1.4.2 market_signals（市场信号表）

**表用途：**
只存储通过所有层级过滤的最终交易信号。通过`snapshot_id`关联到检测快照，实现完整追溯。

**关键字段说明：**

| 字段 | 类型 | 说明 |
|------|------|------|
| `snapshot_id` | BIGINT | 关联检测快照ID（外键） |
| `symbol` | VARCHAR(20) | 币种名称 |
| `signal_type` | VARCHAR(20) | 信号类型：LONG/SHORT |
| `detected_at` | TIMESTAMPTZ | 检测时间 |
| `price` | DECIMAL(20,8) | 检测时的价格 |
| `confidence_score` | DECIMAL(10,2) | 置信度分数（0-100） |
| `signal_strength` | VARCHAR(20) | 信号强度：WEAK/MODERATE/STRONG/VERY_STRONG |
| `position_size_multiplier` | DECIMAL(5,2) | 仓位倍数（1.0=正常，2.0=加倍） |
| `kline_15m_time` | TIMESTAMPTZ | 15分钟K线时间 |
| `kline_4h_time` | TIMESTAMPTZ | 4小时K线时间 |
| `trigger_factors` | JSONB | 触发因素数组，如：["momentum_turn", "volume_surge"] |
| `market_mode` | VARCHAR(20) | 市场模式：BULL/BEAR |
| `multi_tf_aligned` | BOOLEAN | 多时间框架是否对齐 |
| `rsi_value` | DECIMAL(10,4) | RSI值 |
| `macd_histogram` | DECIMAL(20,8) | MACD柱状图值 |
| `volume_ratio` | DECIMAL(10,4) | 成交量比率 |
| `status` | VARCHAR(20) | 信号状态：PENDING/ACTIVE/EXPIRED/FILLED/CANCELLED |
| `expired_at` | TIMESTAMPTZ | 信号过期时间 |
| `opportunity_score_id` | BIGINT | 关联机会评分ID（可选） |
| `trade_id` | BIGINT | 关联交易ID（如果已执行） |

**索引设计：**
- `idx_signal_symbol`：按币种查询
- `idx_signal_time`：按时间查询
- `idx_signal_status`：按状态查询
- `idx_signal_expired`：查询过期信号

**数据关联：**
```
market_signals.snapshot_id → market_detection_snapshots.id
```
通过这个关联，可以从信号追溯到完整的检测过程，包括所有环境层、触发层、确认层的判断结果。

---

## 2. 层级过滤模型架构

### 2.1 三层过滤流程

层级过滤模型采用串行过滤机制，信号必须依次通过三层过滤，任何一层不通过即被过滤。

```
┌─────────────────────────────────────────────────────────┐
│                   检测开始                                │
│             获取15m/4h/1d K线数据                        │
└────────────────────┬──────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│  第一层：环境层 (Filter Layer)                           │
│  ┌─────────────────────────────────────────────────┐   │
│  │ 1. 判断市场模式 (BULL/BEAR/NEUTRAL)             │   │
│  │    - 15m: 价格 vs EMA55                        │   │
│  │ 2. 判断市场活跃度                               │   │
│  │    - 布林带宽度 vs 20根平均值                   │   │
│  │ 3. 多时间框架对齐                               │   │
│  │    - 15m和4h趋势是否一致                        │   │
│  └─────────────────────────────────────────────────┘   │
│  过滤条件：NEUTRAL模式或市场不活跃 → 退出               │
└────────────────────┬──────────────────────────────────────┘
                     │ 通过
                     ▼
┌─────────────────────────────────────────────────────────┐
│  第二层：触发层 (Trigger Layer)                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │ 6个维度并行检测（任一触发即可）：                │   │
│  │ 1. MACD动量转折                                  │   │
│  │ 2. EMA交叉                                      │   │
│  │ 3. RSI极值                                      │   │
│  │ 4. 布林带突破                                   │   │
│  │ 5. 成交量异常                                   │   │
│  │ 6. 价格形态（吞没）                             │   │
│  └─────────────────────────────────────────────────┘   │
│  过滤条件：无任何触发 → 退出                            │
└────────────────────┬──────────────────────────────────────┘
                     │ 通过
                     ▼
┌─────────────────────────────────────────────────────────┐
│  第三层：确认层 (Confirmation Layer)                    │
│  ┌─────────────────────────────────────────────────┐   │
│  │ 1. 成交量确认                                   │   │
│  │    - 动态阈值：均值 + 1.5×标准差                │   │
│  │ 2. 布林带确认                                   │   │
│  │    - 宽度扩大：当前宽度 > 1.2×平均宽度          │   │
│  └─────────────────────────────────────────────────┘   │
│  过滤条件：无任何确认 → 退出                            │
└────────────────────┬──────────────────────────────────────┘
                     │ 通过
                     ▼
┌─────────────────────────────────────────────────────────┐
│              生成交易信号                                │
│  - 计算信号强度 (WEAK/MODERATE/STRONG/VERY_STRONG)     │
│  - 计算置信度分数 (0-100)                               │
│  - 保存快照和信号                                       │
└─────────────────────────────────────────────────────────┘
```

### 2.2 关键设计决策

#### 2.2.1 为什么使用层级过滤而非加权投票？

**层级过滤的优势：**
- **逻辑清晰**：每层职责单一，易于理解和调试
- **不依赖权重参数**：不需要大量回测数据才能确定的权重参数
- **可解释性强**：每层都有明确的过滤目的，结果可追溯

**加权投票的问题：**
- **权重参数缺乏依据**：权重参数（如EMA权重0.25，RSI权重0.1）缺乏统计学依据
- **需要大量回测数据**：需要大量历史数据回测才能确定合理权重
- **容易过拟合**：参数依赖性强，在不同市场环境下可能失效
- **难以调试**：权重调整后难以理解为什么信号变化

**示例对比：**

```
加权投票模型：
Score = EMA(0.25) + MACD(0.2) + Vol(0.2) + Price(0.15) + BB(0.1) + RSI(0.1)
问题：为什么EMA权重是0.25而不是0.3？这个权重在不同市场环境下是否有效？

层级过滤模型：
环境层：确定方向（BULL/BEAR）
触发层：在确定方向上寻找入场点（任一触发即可，因为方向已确定）
确认层：验证信号真实性（至少一个确认，因为这是最后一道防线）
优势：逻辑清晰，每步都有明确目的
```

#### 2.2.2 为什么环境层使用价格行为而非ADX？

**价格行为的优势：**
- **实时性强**：价格相对于EMA的位置是即时的，无滞后
- **逻辑简单**：价格在EMA55之上=多头趋势，之下=空头趋势
- **反应迅速**：能立即捕捉趋势变化

**ADX的问题：**
- **滞后性**：ADX需要多个周期才能确认趋势，等确认时可能已经错过最佳入场点
- **在震荡市中失效**：ADX在震荡市中可能频繁切换状态，产生错误信号
- **计算复杂**：需要计算多个周期的数据，计算成本高

**示例对比：**

```
ADX判断趋势：
1. 计算+DI和-DI（需要14个周期）
2. 计算ADX（需要14个周期的平滑）
3. ADX > 25才认为有趋势
问题：等ADX确认趋势时，价格可能已经走了很远

价格行为判断趋势：
价格 > EMA55 → BULL
价格 < EMA55 → BEAR
优势：即时判断，无滞后
```

#### 2.2.3 为什么触发层使用"任一触发"而确认层需要"至少一个确认"？

**触发层"任一触发"的原因：**
- **已经过环境层过滤**：方向性已确定，假信号已大幅减少
- **6个维度覆盖不同情况**：不同维度在不同市场情况下有效，任一触发都表示有入场机会
- **如果要求全部触发**：信号会过于稀少，可能错过很多机会

**确认层"至少一个确认"的原因：**
- **最后一道防线**：确认层是最后一道防线，必须验证信号的真实性
- **真金白银验证**：成交量和布林带确认都是"真金白银"的验证，不是技术指标
- **如果两个都不确认**：说明可能是假信号，不应该交易

**逻辑流程：**

```
环境层：过滤掉不适合交易的市场状态（NEUTRAL、不活跃）
    ↓
触发层：在确定方向上寻找入场点（任一触发即可，因为方向已确定）
    ↓
确认层：验证信号真实性（至少一个确认，因为这是最后一道防线）
```

### 2.3 数据流图

#### 2.3.1 完整数据流

```
K线同步线程 (KlineSyncManager)
    │
    ├─→ 每15分钟同步15m K线
    │
    ├─→ 保存15m K线到数据库 (klines_15m表)
    │
    ├─→ 更新技术指标 (IndicatorCalculator.update_latest_indicators)
    │   ├─→ 计算EMA（9, 21, 55）
    │   ├─→ 计算RSI（7）
    │   ├─→ 计算MACD（12, 26, 9）
    │   ├─→ 计算布林带（20, 2）
    │   └─→ 计算OBV
    │
    └─→ 触发市场检测 (MarketDetector.detect())
            │
            ├─→ 获取K线数据
            │   ├─→ 15m K线（默认100根，含所有指标）
            │   ├─→ 4h K线（默认60根，含所有指标）
            │   └─→ 1d K线（可选，40根，仅EMA）
            │
            ├─→ 环境层过滤 (_filter_layer)
            │   ├─→ 判断市场模式（BULL/BEAR/NEUTRAL）
            │   ├─→ 判断市场活跃度（布林带宽度）
            │   └─→ 判断多时间框架对齐
            │   │
            │   └─→ 如果NEUTRAL或不活跃 → 保存快照 → 退出
            │
            ├─→ 触发层检测（6个维度并行）
            │   ├─→ MACD动量转折
            │   ├─→ EMA交叉
            │   ├─→ RSI极值
            │   ├─→ 布林带突破
            │   ├─→ 成交量异常
            │   └─→ 价格形态（吞没）
            │   │
            │   └─→ 如果无任何触发 → 保存快照 → 退出
            │
            ├─→ 确认层验证 (_confirmation_layer)
            │   ├─→ 成交量确认（动态阈值）
            │   └─→ 布林带确认（宽度扩大）
            │   │
            │   └─→ 如果无任何确认 → 保存快照 → 退出
            │
            └─→ 生成信号
                ├─→ 计算信号强度 (_calculate_signal_strength)
                ├─→ 计算置信度分数
                ├─→ 保存检测快照 (market_detection_snapshots)
                └─→ 保存交易信号 (market_signals)
```

#### 2.3.2 检测流程伪代码

```python
def detect():
    # 1. 获取K线数据
    klines_15m = get_klines('15m', count=100)
    klines_4h = get_klines('4h', count=60)
    klines_1d = get_klines('1d', count=40) if enable_multi_tf else []
    
    # 2. 环境层过滤
    market_mode, market_active, trend_15m, trend_4h, multi_tf_aligned = filter_layer(klines_15m, klines_4h)
    
    if market_mode == 'NEUTRAL' or not market_active:
        save_snapshot(has_signal=False)
        return None
    
    # 3. 触发层检测
    momentum_turn = check_momentum_turn(klines_15m, market_mode)
    ema_cross = check_ema_cross(klines_15m, market_mode)
    rsi_extreme = check_rsi_extreme(klines_15m, market_mode)
    bb_breakout = check_bb_breakout(klines_15m, market_mode)
    volume_surge = check_volume_surge(klines_15m)
    price_pattern = check_price_pattern(klines_15m, market_mode)
    
    has_trigger = momentum_turn or ema_cross or rsi_extreme or bb_breakout or volume_surge or price_pattern
    
    if not has_trigger:
        save_snapshot(has_signal=False)
        return None
    
    # 4. 确认层验证
    volume_confirm, bb_confirm = confirmation_layer(klines_15m, market_mode)
    
    if not volume_confirm and not bb_confirm:
        save_snapshot(has_signal=False)
        return None
    
    # 5. 生成信号
    signal_strength = calculate_signal_strength(trigger_count, multi_tf_aligned, volume_confirm, bb_confirm)
    confidence_score = calculate_confidence_score(trigger_count, multi_tf_aligned, volume_confirm, bb_confirm)
    
    snapshot_id = save_snapshot(has_signal=True, signal_direction, signal_strength)
    signal_id = save_signal(snapshot_id, signal_direction, confidence_score, signal_strength)
    
    return signal_info
```

### 2.4 层级过滤的数学逻辑

#### 2.4.1 过滤概率

假设每层的通过概率为：
- 环境层通过概率：P1
- 触发层通过概率：P2
- 确认层通过概率：P3

则最终生成信号的概率为：
```
P(signal) = P1 × P2 × P3
```

**示例：**
- 如果P1=0.3（30%的市场状态适合交易）
- P2=0.4（40%的情况下有触发）
- P3=0.5（50%的情况下有确认）

则最终信号概率为：P(signal) = 0.3 × 0.4 × 0.5 = 0.06（6%）

这意味着在100次检测中，大约只有6次会生成信号，确保了信号质量。

#### 2.4.2 信号强度计算

信号强度基于以下因素：
- 触发维度数量（trigger_count）：每个触发维度+1分
- 多时间框架对齐（multi_tf_aligned）：+0.5分
- 成交量确认（volume_confirm）：+1分
- 布林带确认（bb_confirm）：+1分

**计算公式：**
```
score = trigger_count + (0.5 if multi_tf_aligned else 0) + (1 if volume_confirm else 0) + (1 if bb_confirm else 0)

if score >= 4:
    signal_strength = 'VERY_STRONG'
elif score >= 3:
    signal_strength = 'STRONG'
elif score >= 2:
    signal_strength = 'MODERATE'
else:
    signal_strength = 'WEAK'
```

**示例：**
- 触发维度：3个（momentum_turn, ema_cross, volume_surge）
- 多时间框架对齐：是
- 成交量确认：是
- 布林带确认：否

计算：score = 3 + 0.5 + 1 + 0 = 4.5 → `VERY_STRONG`

#### 2.4.3 置信度分数计算

置信度分数（0-100）基于信号强度因素：

```
confidence_score = min(100, 
    (trigger_count × 15) + 
    (10 if multi_tf_aligned else 0) + 
    (15 if volume_confirm else 0) + 
    (15 if bb_confirm else 0)
)
```

**示例：**
- 触发维度：2个 → 30分
- 多时间框架对齐：是 → +10分
- 成交量确认：是 → +15分
- 布林带确认：否 → +0分

计算：confidence_score = 30 + 10 + 15 + 0 = 55分

---

## 3. 环境层详细说明

### 3.1 环境层职责

环境层是三层过滤的第一层，也是最重要的一层。它的主要职责是：

1. **确定市场方向**：判断当前是多头市场、空头市场还是中性市场
2. **判断市场活性**：判断市场是否足够活跃，避免在震荡市交易
3. **多时间框架对齐**：检查15m和4h趋势是否一致，增强信号可靠性

**环境层的核心作用：**
- 过滤掉不适合交易的市场状态（NEUTRAL模式、不活跃市场）
- 为后续层级提供明确的方向性指导（BULL/BEAR）
- 减少假信号，提高信号质量

### 3.2 市场模式判断 (market_mode)

#### 3.2.1 判断逻辑

市场模式基于15分钟K线的价格与EMA55的关系进行判断：

```python
# 获取最新15m K线
latest_15m = klines_15m[-1]
price_15m = latest_15m['close']
ema_55 = latest_15m.get('ema_55')

# 判断趋势方向
if ema_55 is not None:
    if price_15m > ema_55:
        trend_15m = True   # 上涨趋势
        market_mode = 'BULL'
    elif price_15m < ema_55:
        trend_15m = False  # 下跌趋势
        market_mode = 'BEAR'
    else:
        market_mode = 'NEUTRAL'  # 中性市场（价格等于EMA55，极少见）
else:
    market_mode = 'NEUTRAL'  # EMA55未计算，无法判断
```

#### 3.2.2 为什么使用EMA55？

**周期选择理由：**
- **EMA55在15分钟图上的意义**：55 × 15分钟 = 825分钟 ≈ 13.75小时
- **时间跨度**：覆盖了约一个交易日的周期，能有效过滤短期噪音
- **平衡性**：
  - 太短（如EMA9）：过于敏感，容易产生假信号
  - 太长（如EMA200）：过于滞后，错过最佳入场点
  - EMA55：在敏感性和滞后性之间取得平衡

**EMA55的优势：**
- **趋势识别准确**：价格在EMA55之上表示中期上涨趋势，之下表示下跌趋势
- **过滤噪音**：能过滤掉短期波动，只关注中期趋势
- **实时性强**：每根K线都能立即判断，无滞后

#### 3.2.3 市场模式含义

| 模式 | 判断条件 | 含义 | 交易策略 |
|------|----------|------|----------|
| **BULL** | 价格 > EMA55 | 多头市场，中期上涨趋势 | 只寻找做多信号，忽略做空信号 |
| **BEAR** | 价格 < EMA55 | 空头市场，中期下跌趋势 | 只寻找做空信号，忽略做多信号 |
| **NEUTRAL** | 价格 = EMA55 或 EMA55未计算 | 中性市场，趋势不明确 | **不交易，等待明确方向** |

**重要原则：**
- **NEUTRAL模式下，系统不会生成任何交易信号**
- 这是为了避免在震荡市中的假信号
- 即使有技术指标触发，只要市场模式是NEUTRAL，就不会生成信号

**方向性过滤的优势：**
- **避免逆势交易**：在牛市只做多，在熊市只做空
- **减少假信号**：在牛市忽略超买信号（RSI可以钝化），在熊市忽略超卖信号
- **提高成功率**：顺势交易的成功率远高于逆势交易

### 3.3 市场活跃度判断 (market_active)

#### 3.3.1 判断逻辑

市场活跃度基于布林带宽度（bb_width）进行判断：

```python
# 计算最近20根K线的布林带宽度平均值
bb_widths = [
    k.get('bb_width', 0) or 0
    for k in klines_15m[-20:]
    if k.get('bb_width') is not None
]

if bb_widths:
    avg_bb_width = statistics.mean(bb_widths)
    current_bb_width = latest_15m.get('bb_width', 0) or 0
    
    # 判断是否活跃
    threshold = settings.DETECTOR_BB_WIDTH_THRESHOLD  # 默认0.5
    market_active = current_bb_width >= (avg_bb_width * threshold)
else:
    market_active = False  # 数据不足，认为不活跃
```

#### 3.3.2 布林带宽度 (bb_width) 的含义

**计算公式：**
```
bb_width = (bb_upper - bb_lower) / bb_middle
```

**物理意义：**
- **宽度大**：表示价格波动大，市场活跃，趋势明确
- **宽度小**：表示价格波动小，市场不活跃，可能处于震荡或横盘

**市场状态判断：**
- **宽度扩大**：市场波动增加，可能是趋势启动或加速
- **宽度收窄**：市场波动减少，可能是趋势结束或进入震荡
- **宽度极窄**：市场极度不活跃，可能是横盘或等待突破

#### 3.3.3 为什么需要判断市场活跃度？

**避免假信号：**
- 在低波动时期，技术指标可能发出错误信号
- 震荡市中的突破信号往往是假突破
- 横盘市场中的RSI极值可能是噪音

**提高信号质量：**
- 只在市场活跃时交易，信号更可靠
- 活跃市场中的突破信号成功率更高
- 减少在震荡市中的频繁交易

**减少交易成本：**
- 避免在低波动时期的无效交易
- 减少滑点和手续费成本
- 提高整体盈亏比

#### 3.3.4 阈值参数 (DETECTOR_BB_WIDTH_THRESHOLD)

**默认值：** 0.5

**含义：** 当前布林带宽度必须 >= 平均宽度的50%才认为市场活跃

**阈值调整建议：**

| 阈值 | 效果 | 适用场景 |
|------|------|----------|
| **0.3** | 更宽松，信号更多 | 希望增加信号数量，但可能包含更多假信号 |
| **0.5** | 平衡（默认） | 大多数情况下的最佳选择 |
| **0.7** | 更严格，信号更少 | 只捕捉最活跃的市场，信号质量最高 |

**调整方法：**
```sql
-- 更新system_config表
UPDATE system_config 
SET config_value = '0.7' 
WHERE config_key = 'DETECTOR_BB_WIDTH_THRESHOLD';
```

### 3.4 多时间框架对齐 (multi_tf_aligned)

#### 3.4.1 判断逻辑

多时间框架对齐检查15m和4h的趋势是否一致：

```python
# 15m趋势判断
trend_15m = None
if latest_15m.get('ema_55'):
    trend_15m = price_15m > latest_15m['ema_55']

# 4h趋势判断（使用EMA21）
trend_4h = None
if latest_4h.get('ema_21'):
    trend_4h = price_4h > latest_4h['ema_21']

# 多时间框架对齐
multi_tf_aligned = False
if trend_15m is not None and trend_4h is not None:
    multi_tf_aligned = (trend_15m == trend_4h)
```

#### 3.4.2 为什么需要多时间框架对齐？

**趋势确认：**
- 如果15m和4h趋势一致，说明趋势更可靠
- 短期和中期趋势一致时，成功率更高
- 减少假突破，提高信号质量

**减少假信号：**
- 短期突破如果与长期趋势一致，成功率更高
- 如果短期和长期趋势相反，可能是假突破
- 多时间框架共振是趋势交易的核心原则

**信号增强：**
- 多时间框架对齐时，信号强度会提升
- 在计算信号强度时，`multi_tf_aligned`会+0.5分
- 在计算置信度分数时，`multi_tf_aligned`会+10分

#### 3.4.3 时间框架选择

**15m（短期）：**
- **用途**：捕捉短期交易机会，反应速度快
- **EMA周期**：EMA55（约13.75小时）
- **优势**：能快速捕捉趋势变化

**4h（中期）：**
- **用途**：确认中期趋势，过滤短期噪音
- **EMA周期**：EMA21（约84小时，3.5天）
- **优势**：能过滤短期波动，确认中期趋势

**1d（长期，可选）：**
- **用途**：确认长期趋势（通过DETECTOR_ENABLE_MULTI_TF控制）
- **EMA周期**：EMA9, EMA21
- **优势**：确认大方向，但目前未在环境层使用

**时间框架组合：**
- **15m + 4h**：短期和中期趋势对齐，是最常用的组合
- **15m + 4h + 1d**：短期、中期、长期趋势对齐，信号最强，但信号更少

### 3.5 环境层过滤条件

环境层有两个硬性过滤条件，任一不满足即退出检测：

#### 3.5.1 NEUTRAL模式过滤

**条件：** `market_mode == 'NEUTRAL'`

**处理：**
- 直接退出检测，不生成信号
- 仍然保存检测快照（`has_signal = False`）
- 记录市场模式为NEUTRAL，便于后续分析

**原因：**
- NEUTRAL模式表示趋势不明确
- 在趋势不明确时交易，假信号概率高
- 等待明确方向后再交易，提高成功率

#### 3.5.2 市场不活跃过滤

**条件：** `market_active == False`

**处理：**
- 直接退出检测，不生成信号
- 仍然保存检测快照（`has_signal = False`）
- 记录`market_active = False`，便于后续分析

**原因：**
- 市场不活跃时，技术指标可能发出错误信号
- 震荡市中的突破信号往往是假突破
- 只在活跃市场交易，信号更可靠

#### 3.5.3 过滤后的处理

即使被环境层过滤，系统仍会：
1. **保存检测快照**：记录所有环境层判断结果
2. **记录过滤原因**：通过`market_mode`和`market_active`字段记录
3. **支持回溯分析**：可以分析哪些市场状态下信号被过滤

**快照记录内容：**
- `market_mode`: BULL/BEAR/NEUTRAL
- `market_active`: True/False
- `trend_15m`: True/False/None
- `trend_4h`: True/False/None
- `multi_tf_aligned`: True/False
- `has_signal`: False（被过滤）
- `signal_direction`: None

### 3.6 环境层输出

环境层输出以下信息，供后续层级使用：

| 输出变量 | 类型 | 说明 |
|----------|------|------|
| `market_mode` | str | 市场模式：BULL/BEAR/NEUTRAL |
| `market_active` | bool | 市场是否活跃 |
| `trend_15m` | bool/None | 15m趋势方向（True=上涨，False=下跌） |
| `trend_4h` | bool/None | 4h趋势方向 |
| `multi_tf_aligned` | bool | 多时间框架是否对齐 |

**后续层级使用：**
- **触发层**：根据`market_mode`进行方向性过滤
- **确认层**：使用环境层信息进行确认
- **信号生成**：使用`multi_tf_aligned`增强信号强度

---

## 4. 触发层详细说明

### 4.1 触发层职责

触发层是三层过滤的第二层，主要职责是：

1. **寻找入场点**：在环境层确定的方向上，寻找具体的入场时机
2. **多维度检测**：通过6个不同的技术维度，捕捉各种市场情况下的交易机会
3. **方向性过滤**：所有触发条件都根据市场模式（BULL/BEAR）进行方向性判断

**触发层的核心特点：**
- **方向性**：所有触发条件都根据`market_mode`进行方向性判断
- **并行检测**：6个维度并行检测，任一触发即可
- **互补性**：不同维度覆盖不同市场情况，提高信号覆盖率

### 4.2 触发层设计原则

#### 4.2.1 方向性过滤

**BULL模式（多头市场）：**
- 只检测做多信号
- 忽略做空信号（即使RSI超买也不做空）
- 所有触发条件都针对多头方向

**BEAR模式（空头市场）：**
- 只检测做空信号
- 忽略做多信号（即使RSI超卖也不做多）
- 所有触发条件都针对空头方向

**优势：**
- 避免逆势交易，减少假信号
- 在牛市忽略超买信号（RSI可以钝化），在熊市忽略超卖信号
- 提高信号成功率

#### 4.2.2 "任一触发"逻辑

**触发条件：** 6个维度中，**任一触发即可**进入确认层

**原因：**
- 已经经过环境层过滤，方向性已确定，假信号已大幅减少
- 6个维度覆盖不同市场情况，任一触发都表示有入场机会
- 如果要求全部触发，信号会过于稀少，可能错过很多机会

**触发维度：**
1. MACD动量转折
2. EMA交叉
3. RSI极值
4. 布林带突破
5. 成交量异常
6. 价格形态（吞没）

### 4.3 触发维度详解

#### 4.3.1 MACD动量转折 (momentum_turn)

**检测方法：** `_check_momentum_turn()`

**检测逻辑：**

```python
# 获取最新和前一根K线的MACD柱状图值
hist_latest = latest.get('histogram')
hist_prev = prev.get('histogram')

# 多头模式
if market_mode == 'BULL':
    # 情况1：MACD柱从负转正（金叉）
    if hist_prev <= 0 and hist_latest > 0:
        return True, hist_latest
    # 情况2：MACD柱持续增大（动量增强）
    if hist_prev > 0 and hist_latest > hist_prev:
        return True, hist_latest

# 空头模式
elif market_mode == 'BEAR':
    # 情况1：MACD柱从正转负（死叉）
    if hist_prev >= 0 and hist_latest < 0:
        return True, hist_latest
    # 情况2：MACD柱持续减小（动量减弱）
    if hist_prev < 0 and hist_latest < hist_prev:
        return True, hist_latest
```

**物理意义：**
- **MACD柱（Histogram）**：MACD线与信号线的差值，表示动量强度
- **从负转正**：表示多头动量开始增强，可能是趋势启动信号
- **持续增大**：表示动量持续增强，趋势可能加速

**适用场景：**
- 趋势启动初期
- 趋势加速阶段
- 回调后的重新启动

**优势：**
- 能捕捉动量的转折点
- 比单纯看MACD线更敏感
- 能捕捉趋势加速的信号

**示例：**
```
BULL模式：
前一根K线：histogram = -0.5（负值，空头动量）
当前K线：histogram = 0.3（正值，多头动量）
→ 触发：MACD柱从负转正，多头动量启动
```

#### 4.3.2 EMA交叉 (ema_cross)

**检测方法：** `_check_ema_cross()`

**检测逻辑：**

```python
# 获取最新和前一根K线的EMA值
ema9_latest = latest.get('ema_9')
ema21_latest = latest.get('ema_21')
ema9_prev = prev.get('ema_9')
ema21_prev = prev.get('ema_21')

# 多头模式：EMA9上穿EMA21
if market_mode == 'BULL':
    return ema9_prev <= ema21_prev and ema9_latest > ema21_latest

# 空头模式：EMA9下穿EMA21
elif market_mode == 'BEAR':
    return ema9_prev >= ema21_prev and ema9_latest < ema21_latest
```

**物理意义：**
- **EMA9上穿EMA21**：短期均线上穿中期均线，表示短期趋势强于中期趋势
- **EMA9下穿EMA21**：短期均线下穿中期均线，表示短期趋势弱于中期趋势

**适用场景：**
- 趋势启动初期
- 趋势反转点
- 回调后的重新启动

**优势：**
- 经典的均线交叉信号
- 能捕捉趋势启动点
- 信号明确，易于理解

**注意事项：**
- 在震荡市中可能产生假信号（但已通过环境层过滤）
- 需要结合其他维度确认

**示例：**
```
BULL模式：
前一根K线：EMA9 = 100, EMA21 = 101（EMA9 < EMA21）
当前K线：EMA9 = 102, EMA21 = 101（EMA9 > EMA21）
→ 触发：EMA9上穿EMA21，短期趋势强于中期趋势
```

#### 4.3.3 RSI极值 (rsi_extreme)

**检测方法：** `_check_rsi_extreme()`

**检测逻辑：**

```python
# 获取当前RSI值（使用RSI7）
rsi = latest.get('rsi_7')

# 多头模式：RSI超卖反弹
if market_mode == 'BULL':
    rsi_long_threshold = settings.DETECTOR_RSI_LONG_THRESHOLD  # 默认80.0
    rsi_double = settings.DETECTOR_RSI_DOUBLE_POSITION_LONG    # 默认50.0
    
    if rsi < rsi_long_threshold:
        # RSI低于阈值，允许做多
        if rsi < rsi_double:
            position_multiplier = 2.0  # RSI极低，加倍仓位
        else:
            position_multiplier = 1.0
        return True, rsi, position_multiplier

# 空头模式：RSI超买回调
elif market_mode == 'BEAR':
    rsi_short_threshold = settings.DETECTOR_RSI_SHORT_THRESHOLD  # 默认20.0
    rsi_double = settings.DETECTOR_RSI_DOUBLE_POSITION_SHORT     # 默认50.0
    
    if rsi > rsi_short_threshold:
        # RSI高于阈值，允许做空
        if rsi > rsi_double:
            position_multiplier = 2.0  # RSI极高，加倍仓位
        else:
            position_multiplier = 1.0
        return True, rsi, position_multiplier
```

**物理意义：**
- **RSI < 80（多头模式）**：RSI未极端过热，允许做多，防止在极端过热时做多
- **RSI > 20（空头模式）**：RSI未极端超卖，允许做空，防止在极端超卖时做空
- **RSI < 50（多头模式）**：RSI较低，更好的盈亏比，加倍仓位
- **RSI > 50（空头模式）**：RSI较高，更好的盈亏比，加倍仓位

**关键设计：**
- **不是传统的RSI超买超卖**：不是RSI < 30做多，而是RSI < 80才允许做多
- **防止极端过热**：在牛市，如果RSI > 80，即使其他指标触发也不做多
- **仓位管理**：RSI极值时（< 50做多，> 50做空）加倍仓位，提高盈亏比

**适用场景：**
- 趋势中的回调买入/卖出
- 避免在极端过热/超卖时交易
- 在更好的位置入场（RSI适中时）

**优势：**
- 避免在极端位置交易
- 通过仓位管理提高盈亏比
- 在趋势中寻找更好的入场点

**参数说明：**

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `DETECTOR_RSI_LONG_THRESHOLD` | 80.0 | 做多信号RSI上限（RSI低于此值才允许做多） |
| `DETECTOR_RSI_SHORT_THRESHOLD` | 20.0 | 做空信号RSI下限（RSI高于此值才允许做空） |
| `DETECTOR_RSI_DOUBLE_POSITION_LONG` | 50.0 | 做多时RSI低于此值加倍仓位 |
| `DETECTOR_RSI_DOUBLE_POSITION_SHORT` | 50.0 | 做空时RSI高于此值加倍仓位 |

**示例：**
```
BULL模式：
当前RSI = 45
RSI_LONG_THRESHOLD = 80.0
RSI_DOUBLE_POSITION_LONG = 50.0

判断：
- RSI (45) < RSI_LONG_THRESHOLD (80) → 允许做多 ✓
- RSI (45) < RSI_DOUBLE_POSITION_LONG (50) → 加倍仓位 ✓
→ 触发：RSI极值，position_multiplier = 2.0
```

#### 4.3.4 布林带突破 (bb_breakout)

**检测方法：** `_check_bb_breakout()`

**检测逻辑：**

```python
# 获取当前价格和布林带上下轨
close = latest['close']
bb_upper = latest.get('bb_upper')
bb_lower = latest.get('bb_lower')

# 多头模式：价格突破上轨
if market_mode == 'BULL':
    return close > bb_upper

# 空头模式：价格跌破下轨
elif market_mode == 'BEAR':
    return close < bb_lower
```

**物理意义：**
- **价格突破上轨**：价格突破布林带上轨，表示强势上涨，可能继续上涨
- **价格跌破下轨**：价格跌破布林带下轨，表示强势下跌，可能继续下跌

**适用场景：**
- 趋势加速阶段
- 突破关键阻力/支撑位
- 强势行情中的追涨/追跌

**优势：**
- 能捕捉强势突破信号
- 在趋势加速时及时入场
- 信号明确，易于理解

**注意事项：**
- 在震荡市中可能是假突破（但已通过环境层过滤）
- 需要结合成交量确认

**示例：**
```
BULL模式：
当前价格：close = 102
布林带上轨：bb_upper = 100
→ 触发：价格突破上轨，强势上涨
```

#### 4.3.5 成交量异常 (volume_surge)

**检测方法：** `_check_volume_surge()`

**检测逻辑：**

```python
# 计算最近20根K线的平均成交量和标准差
volumes = [k['volume'] for k in klines_15m[-20:]]
avg_volume = statistics.mean(volumes)

# 计算标准差（至少需要2个数据点）
if len(volumes) < 2:
    std_volume = 0
else:
    std_volume = statistics.stdev(volumes)

# 动态阈值
threshold = avg_volume + (settings.DETECTOR_VOLUME_STD_MULTIPLIER * std_volume)
volume_ratio = current_volume / avg_volume if avg_volume > 0 else 0

# 判断是否异常
return current_volume > threshold, volume_ratio
```

**物理意义：**
- **成交量异常**：当前成交量显著高于平均水平，表示市场关注度高
- **动态阈值**：使用统计学方法（均值 + 1.5×标准差），而非固定倍数
- **成交量比率**：当前成交量相对于平均值的倍数

**适用场景：**
- 突破关键位置时的成交量确认
- 趋势启动时的成交量放大
- 重要消息发布时的成交量激增

**优势：**
- 使用统计学方法，适应不同市场环境
- 在低波动时期也能正常检测（不使用固定倍数）
- 能捕捉市场关注度的变化

**参数说明：**

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `DETECTOR_VOLUME_STD_MULTIPLIER` | 1.5 | 成交量确认倍数（平均值 + 此倍数 × 标准差） |

**阈值计算：**
```
阈值 = 平均值 + 1.5 × 标准差

示例：
平均值 = 1000
标准差 = 200
阈值 = 1000 + 1.5 × 200 = 1300

如果当前成交量 > 1300，则触发
```

**调整建议：**
- **降低倍数（如1.0）**：增加信号数量，但可能包含更多假信号
- **提高倍数（如2.0）**：减少信号数量，但信号质量更高

**示例：**
```
最近20根K线成交量：
[800, 900, 1000, 1100, 1200, 950, 1050, ...]

平均值 = 1000
标准差 = 150
阈值 = 1000 + 1.5 × 150 = 1225

当前成交量 = 1500
→ 触发：成交量异常，volume_ratio = 1.5
```

#### 4.3.6 价格形态（吞没形态）(price_pattern)

**检测方法：** `_check_price_pattern()`

**检测逻辑：**

```python
# 获取最新和前一根K线
latest = klines_15m[-1]
prev = klines_15m[-2]

# 多头模式：看涨吞没
if market_mode == 'BULL':
    prev_bearish = prev['close'] < prev['open']  # 前一根是阴线
    latest_bullish = latest['close'] > latest['open']  # 当前是阳线
    engulfed = latest['open'] < prev['close'] and latest['close'] > prev['open']  # 完全吞没
    return prev_bearish and latest_bullish and engulfed

# 空头模式：看跌吞没
elif market_mode == 'BEAR':
    prev_bullish = prev['close'] > prev['open']  # 前一根是阳线
    latest_bearish = latest['close'] < latest['open']  # 当前是阴线
    engulfed = latest['open'] > prev['close'] and latest['close'] < prev['open']  # 完全吞没
    return prev_bullish and latest_bearish and engulfed
```

**物理意义：**
- **看涨吞没**：前一根是阴线，当前是阳线，且当前完全吞没前一根，表示多头力量强于空头
- **看跌吞没**：前一根是阳线，当前是阴线，且当前完全吞没前一根，表示空头力量强于多头

**适用场景：**
- 趋势反转点
- 回调结束后的重新启动
- 关键支撑/阻力位的反转

**优势：**
- 经典的K线形态，可靠性高
- 能捕捉价格行为的转折点
- 信号明确，易于理解

**形态要求：**
1. **前一根和当前颜色相反**：前一根是阴线，当前是阳线（或相反）
2. **完全吞没**：当前K线的实体完全包含前一根K线的实体
3. **方向性**：根据市场模式判断是看涨还是看跌吞没

**示例：**
```
BULL模式：
前一根K线：open = 100, close = 98（阴线）
当前K线：open = 97, close = 101（阳线）

判断：
- prev_bearish = True（前一根是阴线）✓
- latest_bullish = True（当前是阳线）✓
- engulfed = (97 < 98) and (101 > 98) = True（完全吞没）✓
→ 触发：看涨吞没形态
```

### 4.4 触发层过滤条件

触发层有一个硬性过滤条件：

**条件：** 6个维度中，**无任何触发**

**处理：**
- 直接退出检测，不生成信号
- 仍然保存检测快照（`has_signal = False`）
- 记录所有触发维度的检测结果（`momentum_turn`, `ema_cross`, `rsi_extreme`, `bb_breakout`, `volume_surge`, `price_pattern`）

**原因：**
- 如果没有触发，说明当前没有入场机会
- 等待触发条件满足后再交易，提高信号质量

### 4.5 触发层输出

触发层输出以下信息，供后续层级使用：

| 输出变量 | 类型 | 说明 |
|----------|------|------|
| `momentum_turn` | bool | MACD动量转折是否触发 |
| `ema_cross` | bool | EMA交叉是否触发 |
| `rsi_extreme` | bool | RSI极值是否触发 |
| `bb_breakout` | bool | 布林带突破是否触发 |
| `volume_surge` | bool | 成交量异常是否触发 |
| `price_pattern` | bool | 价格形态是否触发 |
| `rsi_value` | float/None | 当前RSI值 |
| `macd_histogram` | float/None | MACD柱状图值 |
| `volume_ratio` | float/None | 成交量比率（当前/平均） |
| `rsi_multiplier` | float | 仓位倍数（1.0或2.0） |

**后续层级使用：**
- **确认层**：使用触发层信息进行确认
- **信号生成**：统计触发维度数量，计算信号强度

---

## 5. 确认层详细说明

### 5.1 确认层职责

确认层是三层过滤的最后一层，也是最关键的一层。它的主要职责是：

1. **验证信号真实性**：确保信号是真金白银的突破，而非技术指标的假信号
2. **成交量确认**：验证是否有足够的成交量支撑价格行为
3. **布林带确认**：验证市场波动是否扩大，确认突破的有效性

**确认层的核心作用：**
- 最后一道防线，过滤掉假信号
- 使用"真金白银"的验证（成交量和波动率），而非技术指标
- 确保信号的真实性和可靠性

### 5.2 确认层设计原则

#### 5.2.1 "至少一个确认"逻辑

**确认条件：** 成交量和布林带确认中，**至少一个确认**才能生成信号

**原因：**
- 确认层是最后一道防线，必须验证信号的真实性
- 成交量和布林带确认都是"真金白银"的验证，不是技术指标
- 如果两个都不确认，说明可能是假信号，不应该交易

**确认维度：**
1. **成交量确认**：验证是否有足够的成交量支撑
2. **布林带确认**：验证市场波动是否扩大

#### 5.2.2 为什么需要确认层？

**技术指标的局限性：**
- 技术指标可能发出假信号
- 价格突破可能是假突破
- 需要"真金白银"的验证

**确认层的价值：**
- **成交量确认**：真金白银的流入/流出，难以造假
- **布林带确认**：市场波动的扩大，确认突破的有效性
- 两者结合，大幅提高信号可靠性

### 5.3 成交量确认 (volume_confirm)

#### 5.3.1 检测逻辑

成交量确认使用与触发层相同的检测方法（`_check_volume_surge()`），但目的不同：

**触发层：** 成交量异常作为触发条件之一
**确认层：** 成交量异常作为确认条件，验证信号真实性

```python
# 计算最近20根K线的平均成交量和标准差
volumes = [k['volume'] for k in klines_15m[-20:]]
avg_volume = statistics.mean(volumes)

# 计算标准差（至少需要2个数据点）
if len(volumes) < 2:
    std_volume = 0
else:
    std_volume = statistics.stdev(volumes)

# 动态阈值
threshold = avg_volume + (settings.DETECTOR_VOLUME_STD_MULTIPLIER * std_volume)
volume_ratio = current_volume / avg_volume if avg_volume > 0 else 0

# 判断是否确认
volume_confirm = current_volume > threshold
```

#### 5.3.2 物理意义

**成交量确认的含义：**
- **成交量放大**：表示市场关注度高，有真金白银流入/流出
- **突破有支撑**：价格突破如果有成交量支撑，成功率更高
- **真金白银验证**：成交量难以造假，是市场真实情绪的反映

**为什么成交量重要？**
- **价格可以操纵**：大户可以通过少量资金操纵价格
- **成交量难以操纵**：需要大量资金才能放大成交量
- **价量配合**：价格突破 + 成交量放大 = 真实突破

#### 5.3.3 动态阈值优势

**传统方法（固定倍数）：**
```
阈值 = 平均值 × 2.0
问题：在低波动时期，可能永远达不到2倍，导致几个月都不开单
```

**动态阈值（统计学方法）：**
```
阈值 = 平均值 + 1.5 × 标准差
优势：适应不同市场环境，在低波动时期也能正常检测
```

**示例对比：**

```
场景1：高波动市场
平均值 = 1000
标准差 = 500
固定倍数阈值 = 1000 × 2.0 = 2000
动态阈值 = 1000 + 1.5 × 500 = 1750
当前成交量 = 1800
→ 固定倍数：未触发（1800 < 2000）
→ 动态阈值：触发（1800 > 1750）✓

场景2：低波动市场
平均值 = 1000
标准差 = 100
固定倍数阈值 = 1000 × 2.0 = 2000
动态阈值 = 1000 + 1.5 × 100 = 1150
当前成交量 = 1200
→ 固定倍数：未触发（1200 < 2000）
→ 动态阈值：触发（1200 > 1150）✓
```

#### 5.3.4 参数调整

**参数：** `DETECTOR_VOLUME_STD_MULTIPLIER`（默认1.5）

**调整建议：**

| 倍数 | 效果 | 适用场景 |
|------|------|----------|
| **1.0** | 更宽松，信号更多 | 希望增加信号数量，但可能包含更多假信号 |
| **1.5** | 平衡（默认） | 大多数情况下的最佳选择 |
| **2.0** | 更严格，信号更少 | 只捕捉最明显的成交量异常，信号质量最高 |

**调整方法：**
```sql
-- 更新system_config表
UPDATE system_config 
SET config_value = '2.0' 
WHERE config_key = 'DETECTOR_VOLUME_STD_MULTIPLIER';
```

### 5.4 布林带确认 (bb_confirm)

#### 5.4.1 检测逻辑

```python
# 计算最近20根K线的布林带宽度平均值
bb_widths = [
    k.get('bb_width', 0) or 0
    for k in klines_15m[-20:]
    if k.get('bb_width') is not None
]

if bb_widths and current_bb_width > 0:
    avg_bb_width = statistics.mean(bb_widths)
    if avg_bb_width > 0:
        bb_width_ratio = current_bb_width / avg_bb_width
        # 布林带宽度扩大（突破确认）
        bb_confirm = bb_width_ratio > 1.2
```

#### 5.4.2 物理意义

**布林带宽度扩大的含义：**
- **波动率增加**：市场波动扩大，表示市场活跃度提高
- **突破有效**：价格突破如果伴随波动率扩大，说明突破有效
- **趋势启动**：波动率扩大往往是趋势启动的信号

**为什么需要布林带确认？**
- **假突破识别**：如果价格突破但波动率未扩大，可能是假突破
- **趋势确认**：波动率扩大确认趋势的有效性
- **市场活跃度**：波动率扩大表示市场关注度提高

#### 5.4.3 阈值说明

**阈值：** `bb_width_ratio > 1.2`

**含义：** 当前布林带宽度必须 > 平均宽度的120%才认为确认

**为什么是1.2？**
- **平衡性**：既不会太严格（如1.5），也不会太宽松（如1.1）
- **经验值**：经过测试，1.2是较好的平衡点
- **可调整**：如果需要，可以修改代码中的1.2阈值

**示例：**
```
最近20根K线布林带宽度：
[0.02, 0.025, 0.03, 0.028, 0.032, ...]

平均值 = 0.028
当前宽度 = 0.035
宽度比率 = 0.035 / 0.028 = 1.25

判断：
bb_width_ratio (1.25) > 1.2 → 确认 ✓
```

### 5.5 确认层过滤条件

确认层有一个硬性过滤条件：

**条件：** 成交量和布林带确认中，**无任何确认**

**处理：**
- 直接退出检测，不生成信号
- 仍然保存检测快照（`has_signal = False`）
- 记录确认层检测结果（`volume_confirm`, `bb_confirm`）

**原因：**
- 如果没有确认，说明可能是假信号
- 等待确认条件满足后再交易，提高信号质量
- 确保信号的真实性和可靠性

### 5.6 确认层输出

确认层输出以下信息，供信号生成使用：

| 输出变量 | 类型 | 说明 |
|----------|------|------|
| `volume_confirm` | bool | 成交量是否确认 |
| `bb_confirm` | bool | 布林带是否确认 |
| `volume_ratio` | float/None | 成交量比率（当前/平均） |
| `bb_width_ratio` | float/None | 布林带宽度比率（当前/平均） |

**后续使用：**
- **信号生成**：使用确认层信息计算信号强度和置信度分数
- **信号强度**：每个确认+1分
- **置信度分数**：每个确认+15分

### 5.7 确认层与触发层的关系

#### 5.7.1 成交量在两层中的作用

**触发层：** 成交量异常作为触发条件之一
- 如果成交量异常，可能触发信号
- 但还需要其他触发条件（任一触发即可）

**确认层：** 成交量异常作为确认条件
- 无论触发层是否通过成交量触发，都需要成交量确认
- 这是最后一道防线，确保信号真实性

**示例：**
```
场景1：成交量在触发层触发
触发层：volume_surge = True（成交量异常触发）
确认层：volume_confirm = True（成交量确认）
→ 通过确认层 ✓

场景2：成交量在触发层未触发，但在确认层确认
触发层：volume_surge = False（成交量未触发，但其他维度触发）
确认层：volume_confirm = True（成交量确认）
→ 通过确认层 ✓

场景3：成交量在触发层触发，但在确认层未确认
触发层：volume_surge = True（成交量异常触发）
确认层：volume_confirm = False（成交量未确认，且布林带也未确认）
→ 未通过确认层 ✗
```

#### 5.7.2 为什么需要两层都检查成交量？

**触发层检查：** 捕捉成交量异常作为入场信号
**确认层检查：** 验证信号真实性，确保是真金白银的突破

**优势：**
- 即使触发层不是通过成交量触发，也需要成交量确认
- 确保所有信号都有成交量支撑
- 提高信号可靠性

---

## 6. 配置参数、数据流和使用说明

### 6.1 配置参数详细说明

所有市场检测器的配置参数都存储在`system_config`表中，可以在运行时动态调整，无需重启服务。

#### 6.1.1 环境层参数

##### DETECTOR_EMA_TREND_PERIOD

**参数名：** `DETECTOR_EMA_TREND_PERIOD`  
**类型：** `int`  
**默认值：** `55`  
**说明：** 用于趋势判断的EMA周期（环境层）

**作用：**
- 在15分钟K线上使用EMA55判断市场模式
- 价格 > EMA55 → BULL（多头市场）
- 价格 < EMA55 → BEAR（空头市场）
- 价格 = EMA55 → NEUTRAL（中性市场）

**调整建议：**
- **减小周期（如45）**：更敏感，能更快捕捉趋势变化，但可能产生更多假信号
- **增大周期（如65）**：更稳定，过滤更多噪音，但可能滞后

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '45' 
WHERE config_key = 'DETECTOR_EMA_TREND_PERIOD';
```

##### DETECTOR_BB_WIDTH_THRESHOLD

**参数名：** `DETECTOR_BB_WIDTH_THRESHOLD`  
**类型：** `float`  
**默认值：** `0.5`  
**说明：** 布林带宽度阈值（相对于20根平均值的倍数），低于此值认为市场不活跃

**作用：**
- 判断市场是否活跃
- 当前宽度 >= 平均值 × 阈值 → 市场活跃
- 当前宽度 < 平均值 × 阈值 → 市场不活跃（不交易）

**调整建议：**

| 阈值 | 效果 | 适用场景 |
|------|------|----------|
| **0.3** | 更宽松，信号更多 | 希望增加信号数量，但可能包含更多假信号 |
| **0.5** | 平衡（默认） | 大多数情况下的最佳选择 |
| **0.7** | 更严格，信号更少 | 只捕捉最活跃的市场，信号质量最高 |

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '0.7' 
WHERE config_key = 'DETECTOR_BB_WIDTH_THRESHOLD';
```

#### 6.1.2 触发层参数

##### DETECTOR_RSI_LONG_THRESHOLD

**参数名：** `DETECTOR_RSI_LONG_THRESHOLD`  
**类型：** `float`  
**默认值：** `80.0`  
**说明：** 做多信号RSI上限（RSI低于此值才允许做多，防止极端过热）

**作用：**
- 在BULL模式下，只有当RSI < 此阈值时才允许做多
- 防止在极端过热时做多（RSI可以钝化，但超过80通常表示极端过热）
- 不是传统的RSI超买超卖（不是RSI < 30做多）

**调整建议：**
- **降低阈值（如75）**：更保守，避免在过热时做多
- **提高阈值（如85）**：更激进，允许在更高RSI时做多（不推荐）

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '75.0' 
WHERE config_key = 'DETECTOR_RSI_LONG_THRESHOLD';
```

##### DETECTOR_RSI_SHORT_THRESHOLD

**参数名：** `DETECTOR_RSI_SHORT_THRESHOLD`  
**类型：** `float`  
**默认值：** `20.0`  
**说明：** 做空信号RSI下限（RSI高于此值才允许做空，防止极端超卖）

**作用：**
- 在BEAR模式下，只有当RSI > 此阈值时才允许做空
- 防止在极端超卖时做空（RSI可以钝化，但低于20通常表示极端超卖）
- 不是传统的RSI超买超卖（不是RSI > 70做空）

**调整建议：**
- **提高阈值（如25）**：更保守，避免在超卖时做空
- **降低阈值（如15）**：更激进，允许在更低RSI时做空（不推荐）

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '25.0' 
WHERE config_key = 'DETECTOR_RSI_SHORT_THRESHOLD';
```

##### DETECTOR_RSI_DOUBLE_POSITION_LONG

**参数名：** `DETECTOR_RSI_DOUBLE_POSITION_LONG`  
**类型：** `float`  
**默认值：** `50.0`  
**说明：** 做多时RSI低于此值加倍仓位（更好的盈亏比）

**作用：**
- 在BULL模式下，如果RSI < 此阈值，`position_size_multiplier = 2.0`
- 否则，`position_size_multiplier = 1.0`
- 在更好的位置（RSI适中）入场，提高盈亏比

**调整建议：**
- **降低阈值（如40）**：只在RSI更低时加倍仓位，更保守
- **提高阈值（如60）**：在RSI更高时也加倍仓位，更激进

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '40.0' 
WHERE config_key = 'DETECTOR_RSI_DOUBLE_POSITION_LONG';
```

##### DETECTOR_RSI_DOUBLE_POSITION_SHORT

**参数名：** `DETECTOR_RSI_DOUBLE_POSITION_SHORT`  
**类型：** `float`  
**默认值：** `50.0`  
**说明：** 做空时RSI高于此值加倍仓位（更好的盈亏比）

**作用：**
- 在BEAR模式下，如果RSI > 此阈值，`position_size_multiplier = 2.0`
- 否则，`position_size_multiplier = 1.0`
- 在更好的位置（RSI适中）入场，提高盈亏比

**调整建议：**
- **提高阈值（如60）**：只在RSI更高时加倍仓位，更保守
- **降低阈值（如40）**：在RSI更低时也加倍仓位，更激进

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '60.0' 
WHERE config_key = 'DETECTOR_RSI_DOUBLE_POSITION_SHORT';
```

#### 6.1.3 确认层参数

##### DETECTOR_VOLUME_STD_MULTIPLIER

**参数名：** `DETECTOR_VOLUME_STD_MULTIPLIER`  
**类型：** `float`  
**默认值：** `1.5`  
**说明：** 成交量确认阈值（平均值 + 此倍数 × 标准差），降低此值可增加信号数量

**作用：**
- 计算成交量确认的动态阈值：`阈值 = 平均值 + 此倍数 × 标准差`
- 当前成交量 > 阈值 → 成交量确认
- 使用统计学方法，适应不同市场环境

**调整建议：**

| 倍数 | 效果 | 适用场景 |
|------|------|----------|
| **1.0** | 更宽松，信号更多 | 希望增加信号数量，但可能包含更多假信号 |
| **1.5** | 平衡（默认） | 大多数情况下的最佳选择 |
| **2.0** | 更严格，信号更少 | 只捕捉最明显的成交量异常，信号质量最高 |

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '2.0' 
WHERE config_key = 'DETECTOR_VOLUME_STD_MULTIPLIER';
```

#### 6.1.4 数据量参数

##### DETECTOR_KLINE_15M_COUNT

**参数名：** `DETECTOR_KLINE_15M_COUNT`  
**类型：** `int`  
**默认值：** `100`  
**说明：** 使用的15分钟K线数量

**作用：**
- 检测时获取的15m K线数量
- 用于计算技术指标和判断市场状态
- 100根 ≈ 25小时的数据

**调整建议：**
- **减少数量（如80）**：使用更少数据，计算更快，但可能不够全面
- **增加数量（如120）**：使用更多数据，更全面，但计算稍慢

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '120' 
WHERE config_key = 'DETECTOR_KLINE_15M_COUNT';
```

##### DETECTOR_KLINE_4H_COUNT

**参数名：** `DETECTOR_KLINE_4H_COUNT`  
**类型：** `int`  
**默认值：** `60`  
**说明：** 使用的4小时K线数量

**作用：**
- 检测时获取的4h K线数量
- 用于判断4h趋势和多时间框架对齐
- 60根 ≈ 10天的数据

**调整建议：**
- **减少数量（如50）**：使用更少数据，计算更快
- **增加数量（如80）**：使用更多数据，更全面

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '80' 
WHERE config_key = 'DETECTOR_KLINE_4H_COUNT';
```

#### 6.1.5 其他参数

##### DETECTOR_ENABLE_MULTI_TF

**参数名：** `DETECTOR_ENABLE_MULTI_TF`  
**类型：** `bool`  
**默认值：** `True`  
**说明：** 是否启用多时间框架确认（15m和4h共振加分）

**作用：**
- `True`：启用多时间框架确认，15m和4h趋势对齐时信号强度+0.5分，置信度+10分
- `False`：不启用多时间框架确认

**调整建议：**
- **True（推荐）**：提高信号质量，减少假信号
- **False**：增加信号数量，但可能包含更多假信号

**调整方法：**
```sql
UPDATE system_config 
SET config_value = 'false' 
WHERE config_key = 'DETECTOR_ENABLE_MULTI_TF';
```

##### DETECTOR_SIGNAL_EXPIRE_HOURS

**参数名：** `DETECTOR_SIGNAL_EXPIRE_HOURS`  
**类型：** `int`  
**默认值：** `4`  
**说明：** 信号有效期（小时），超过此时间信号自动过期

**作用：**
- 信号生成后，`expired_at = detected_at + 此小时数`
- 超过有效期后，信号状态自动变为`EXPIRED`
- 避免使用过时的信号

**调整建议：**
- **减少时间（如2小时）**：信号有效期更短，更及时
- **增加时间（如6小时）**：信号有效期更长，但可能使用过时信号

**调整方法：**
```sql
UPDATE system_config 
SET config_value = '6' 
WHERE config_key = 'DETECTOR_SIGNAL_EXPIRE_HOURS';
```

#### 6.1.6 参数配置总结表

| 参数名 | 类型 | 默认值 | 层级 | 作用 |
|--------|------|--------|------|------|
| `DETECTOR_EMA_TREND_PERIOD` | int | 55 | 环境层 | EMA趋势判断周期 |
| `DETECTOR_BB_WIDTH_THRESHOLD` | float | 0.5 | 环境层 | 布林带宽度阈值 |
| `DETECTOR_RSI_LONG_THRESHOLD` | float | 80.0 | 触发层 | 做多RSI上限 |
| `DETECTOR_RSI_SHORT_THRESHOLD` | float | 20.0 | 触发层 | 做空RSI下限 |
| `DETECTOR_RSI_DOUBLE_POSITION_LONG` | float | 50.0 | 触发层 | 做多加倍仓位RSI阈值 |
| `DETECTOR_RSI_DOUBLE_POSITION_SHORT` | float | 50.0 | 触发层 | 做空加倍仓位RSI阈值 |
| `DETECTOR_VOLUME_STD_MULTIPLIER` | float | 1.5 | 确认层 | 成交量确认倍数 |
| `DETECTOR_KLINE_15M_COUNT` | int | 100 | 数据量 | 15m K线数量 |
| `DETECTOR_KLINE_4H_COUNT` | int | 60 | 数据量 | 4h K线数量 |
| `DETECTOR_ENABLE_MULTI_TF` | bool | True | 其他 | 是否启用多时间框架 |
| `DETECTOR_SIGNAL_EXPIRE_HOURS` | int | 4 | 其他 | 信号有效期（小时） |

#### 6.1.7 参数调整最佳实践

**1. 测试环境调整**
- 先在测试环境调整参数
- 观察信号数量和质量的变化
- 通过`market_detection_snapshots`表分析调整效果

**2. 渐进式调整**
- 不要一次性调整多个参数
- 每次只调整一个参数，观察效果
- 记录调整前后的信号对比

**3. 参数组合优化**
- 不同参数组合可能产生不同效果
- 需要系统性测试不同组合
- 建议使用回测数据验证

**4. 监控和反馈**
- 调整后监控信号质量
- 通过实际交易结果反馈调整
- 持续优化参数配置

---

**步骤6完成。** 已添加第6章第一部分"配置参数详细说明"的完整内容，包括：
- 环境层参数（EMA周期、布林带宽度阈值）
- 触发层参数（RSI相关参数）
- 确认层参数（成交量确认倍数）
- 数据量参数（K线数量）
- 其他参数（多时间框架、信号有效期）
- 参数配置总结表和调整最佳实践

是否继续步骤7：数据流、使用说明和总结？
