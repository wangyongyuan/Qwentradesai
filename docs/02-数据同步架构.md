# 数据同步架构文档

## 一、概述

### 1.1 数据同步模块职责

数据同步模块是系统的核心基础模块，负责从外部数据源（OKX交易所、CoinGlass）实时同步市场数据到本地PostgreSQL数据库。

**主要职责**：
- 实时同步市场数据（K线、资金费率、未平仓合约等）
- 历史数据补全（系统启动时自动补全缺失数据）
- 数据质量保证（去重、验证、错误处理）
- 技术指标计算（K线同步时自动计算技术指标）

**设计特点**：
- 多线程架构：每个币种、每种数据类型独立同步线程
- 自动重试：网络异常自动重试，保证数据完整性
- 限流保护：通过APIManager统一限流，避免API限流
- 断点续传：支持检测和补全数据断点

### 1.2 数据源说明

**OKX交易所API**（通过CCXT库）：
- K线数据（15m/4h/1d）
- 资金费率
- 盘口挂单
- 订单历史
- 仓位历史

**CoinGlass API**：
- 未平仓合约
- 市场情绪
- ETF资金流（BTC/ETH）
- 恐惧贪婪指数
- 爆仓历史

### 1.3 同步策略总览

| 数据类型 | 数据源 | 同步频率 | 线程模型 | 历史补全 |
|---------|--------|----------|----------|----------|
| K线（15m/4h/1d） | OKX | 实时（K线收盘后） | 每币种1线程 | 支持 |
| 资金费率 | OKX | 每8小时 | 每币种1线程 | 支持 |
| 未平仓合约 | CoinGlass | 每15分钟 | 每币种1线程 | 支持 |
| 市场情绪 | CoinGlass | 每小时 | 每币种1线程 | 支持 |
| 盘口挂单 | OKX | 每小时 | 每币种1线程 | 不支持 |
| ETF资金流 | CoinGlass | 每天8点 | 每币种1线程（仅BTC/ETH） | 支持 |
| 恐惧贪婪指数 | CoinGlass | 每天 | 全局1线程 | 支持 |
| 爆仓历史 | CoinGlass | 每小时 | 每币种1线程 | 支持 |
| 订单历史 | OKX | 每30秒+历史补全 | 全局1线程 | 支持 |
| 仓位历史 | OKX | 每30秒+历史补全 | 全局1线程 | 支持 |

## 二、K线数据同步

### 2.1 KlineSyncManager 设计

**类结构**：
```python
class KlineSyncManager(threading.Thread):
    - api_manager: APIManager  # API管理器
    - symbol: str  # 币种名称（BTC, ETH等）
    - ccxt_symbol: str  # CCXT格式（BTC/USDT:USDT）
    - indicator_calculator: IndicatorCalculator  # 技术指标计算器
    - market_detector: MarketDetector  # 市场检测器（可选）
    - last_sync_15m/4h/1d: datetime  # 最后同步时间
```

**初始化流程**：
1. 继承threading.Thread，创建后台线程
2. 注入APIManager依赖
3. 初始化IndicatorCalculator（技术指标计算器）
4. 可选注入MarketDetector（市场检测器）
5. 初始化同步状态（last_sync_15m/4h/1d）

**线程命名**：`KlineSyncThread-{symbol}`，便于日志追踪

### 2.2 同步策略（15m/4h/1d）

**15分钟K线同步**：
- **同步时机**：每15分钟整点（00, 15, 30, 45分）
- **触发条件**：
  - 分钟数 % 15 == 0 且 秒数 < 10
  - 距离上次同步超过10分钟（避免重复同步）
- **实现逻辑**：
  ```python
  def _should_sync_15m(self, now: datetime) -> bool:
      minute = now.minute
      second = now.second
      if minute % 15 == 0 and second < 10:
          if self.last_sync_15m is None:
              return True
          if (now - self.last_sync_15m).total_seconds() > 600:
              return True
      return False
  ```

**4小时K线同步**：
- **同步时机**：每4小时整点（0:00, 4:00, 8:00, 12:00, 16:00, 20:00）
- **触发条件**：
  - 小时数 % 4 == 0 且 分钟数 < 10 且 秒数 < 10
  - 距离上次同步超过3小时
- **实现逻辑**：
  ```python
  def _should_sync_4h(self, now: datetime) -> bool:
      hour = now.hour
      minute = now.minute
      second = now.second
      if hour % 4 == 0 and minute < 10 and second < 10:
          if self.last_sync_4h is None:
              return True
          if (now - self.last_sync_4h).total_seconds() > 10800:
              return True
      return False
  ```

**日线K线同步**：
- **同步时机**：每天0:00
- **触发条件**：
  - 小时数 == 0 且 分钟数 < 10 且 秒数 < 10
  - 距离上次同步超过20小时
- **实现逻辑**：
  ```python
  def _should_sync_1d(self, now: datetime) -> bool:
      hour = now.hour
      minute = now.minute
      second = now.second
      if hour == 0 and minute < 10 and second < 10:
          if self.last_sync_1d is None:
              return True
          if (now - self.last_sync_1d).total_seconds() > 72000:
              return True
      return False
  ```

**主循环**：
- 每秒检查一次是否需要同步
- 检查三个时间周期（15m/4h/1d）
- 满足条件时调用`_fetch_and_save_klines()`同步数据

### 2.3 历史数据补全机制

**启动时补全**：
- 系统启动时自动调用`_sync_initial_data()`
- 根据配置补全历史数据：
  - 15分钟K线：30天（KLINE_15M_START_DAYS）
  - 4小时K线：180天（KLINE_4H_START_DAYS）
  - 日线：600天（KLINE_1D_START_DAYS）

**智能补全流程**（`_smart_sync_klines`）：
1. **计算补全范围**：
   - 从配置读取开始天数
   - 计算开始时间 = 当前时间 - 开始天数
   - 查询数据库最新K线时间

2. **判断补全策略**：
   - 如果数据库为空：从开始时间补全到当前时间
   - 如果最新时间 < 开始时间：补全两段（开始时间→最新时间，最新时间→当前时间）
   - 如果最新时间在范围内：只补全最新时间→当前时间

3. **批量获取数据**：
   - 调用`_fetch_klines_batch()`批量获取
   - 每批最多200根K线
   - 避免API限流

4. **断点检测和补全**：
   - 调用`_detect_gaps()`检测时间序列断点
   - 对每个断点调用`_fetch_klines_batch()`补全

5. **技术指标计算**：
   - 更新最新指标（`update_latest_indicators`）
   - 批量更新所有历史指标（`batch_update_all_indicators`）

### 2.4 断点续传实现

**断点检测**（`_detect_gaps`）：
1. **获取时间范围内的所有K线时间**：
   - 使用`KlineRepository.get_klines_dataframe()`获取
   - 限制100000根（足够大的数量）

2. **检查第一个时间点**：
   - 如果第一个时间点 > 开始时间，说明开头有断点
   - 断点范围：[开始时间, 第一个时间点 - 1个周期]

3. **检查中间断点**：
   - 遍历所有时间点，检查相邻时间点间隔
   - 如果间隔 > 1个周期，说明有断点
   - 断点范围：[上一个时间点 + 1个周期, 下一个时间点 - 1个周期]

4. **检查最后一个时间点**：
   - 如果最后一个时间点 < 结束时间，说明结尾有断点
   - 断点范围：[最后一个时间点 + 1个周期, 结束时间]

**批量获取**（`_fetch_klines_batch`）：
- **参数**：
  - `timeframe`: 时间周期
  - `start_time`: 开始时间
  - `end_time`: 结束时间
  - `batch_size`: 每批数量（默认200）

- **流程**：
  1. 计算时间间隔（15m=900秒，4h=14400秒，1d=86400秒）
  2. 从开始时间循环到结束时间
  3. 每批计算需要获取的数量（基于时间差和间隔）
  4. 调用API获取K线数据
  5. 转换格式并保存到数据库
  6. 更新当前时间（使用最后获取的K线时间）
  7. 等待0.5秒避免请求过快

- **错误处理**：
  - 单批失败：记录日志，跳过当前批次，继续下一批
  - 保证整体补全流程不中断

### 2.5 技术指标计算流程

**指标计算时机**：
- K线数据保存后立即计算
- 历史数据补全后批量计算

**计算流程**：
1. **数据保存**：
   - 调用`KlineRepository.insert_klines()`保存K线数据
   - 使用`ON CONFLICT`处理重复数据

2. **更新最新指标**：
   - 调用`indicator_calculator.update_latest_indicators()`
   - 只计算最新K线的指标（增量计算）

3. **批量更新历史指标**：
   - 历史数据补全后调用`batch_update_all_indicators()`
   - 批量计算所有K线的指标

**计算的指标**：
- **15分钟K线**：
  - EMA(9, 21, 55)
  - RSI(7)
  - MACD(8, 17, 9)
  - 布林带(20, 2)
  - ATR(14)
  - OBV + OBV_EMA(9)
  - ADX(14)
  - 布林带宽度

- **4小时K线**：
  - EMA(9, 21)
  - RSI(14)
  - MACD(12, 26, 9)
  - 布林带(20, 2)

- **日线**：
  - EMA(9, 21)
  - RSI(14)
  - MACD(12, 26, 9)

### 2.6 与市场检测器的集成

**集成方式**：
- 通过构造函数注入MarketDetector（可选）
- 15分钟K线更新后自动触发检测

**触发逻辑**：
```python
# 15m K线更新后触发市场检测
if timeframe == '15m' and self.market_detector:
    try:
        self.market_detector.detect()
    except Exception as e:
        logger.error(f"[{self.symbol}] 触发市场检测失败: {e}", exc_info=True)
```

**设计考虑**：
- 检测失败不影响K线同步
- 异步触发，不阻塞同步流程
- 目前仅ETH币种配置了MarketDetector

### 2.7 错误处理和重试

**错误分类**：
1. **API调用失败**：
   - 网络异常：通过APIManager自动重试（最多3次）
   - API限流：通过APIManager限流保护
   - 返回None或空列表：记录警告，返回False

2. **数据保存失败**：
   - 数据库连接异常：记录错误，返回False
   - 数据格式错误：记录警告，跳过当前K线

3. **指标计算失败**：
   - 计算异常：记录错误，不影响数据保存
   - 数据不足：记录警告，跳过计算

**重试策略**：
- API调用：通过APIManager统一重试（最多3次）
- 同步循环：异常后等待10秒再继续
- 历史补全：单批失败跳过，继续下一批

**日志记录**：
- 成功：记录INFO级别日志
- 警告：记录WARNING级别日志（数据为空、格式错误等）
- 错误：记录ERROR级别日志（包含完整堆栈信息）

### 三、资金费率同步
- 3.1 FundingRateSyncManager 设计
- 3.2 同步时机（每8小时）
- 3.3 历史数据补全
- 3.4 数据格式说明

### 四、未平仓合约同步
- 4.1 OpenInterestSyncManager 设计
- 4.2 CoinGlass API 调用
- 4.3 同步频率和策略
- 4.4 数据格式说明

### 五、市场情绪同步
- 5.1 MarketSentimentSyncManager 设计
- 5.2 数据源和API
- 5.3 同步策略
- 5.4 数据格式说明

### 六、盘口挂单同步
- 6.1 OrderBookSyncManager 设计
- 6.2 OKX API 调用
- 6.3 同步频率
- 6.4 数据格式说明

### 七、ETF资金流同步
- 7.1 ETFFlowSyncManager 设计
- 7.2 支持币种（BTC/ETH）
- 7.3 同步时机（每天8点）
- 7.4 数据格式说明

### 八、恐惧贪婪指数同步
- 8.1 FearGreedSyncManager 设计
- 8.2 全局唯一实例
- 8.3 同步策略
- 8.4 数据格式说明

### 九、爆仓历史同步
- 9.1 LiquidationSyncManager 设计
- 9.2 同步策略
- 9.3 数据格式说明

### 十、订单历史同步
- 10.1 OrderHistorySyncManager 设计
- 10.2 实时同步策略
- 10.3 历史数据补全
- 10.4 与WebSocket协调
- 10.5 去重机制
- 10.6 多币种同步

### 十一、仓位历史同步
- 11.1 PositionHistorySyncManager 设计
- 11.2 实时同步策略
- 11.3 历史数据补全
- 11.4 多币种同步

### 十二、线程模型
- 12.1 线程设计原则
- 12.2 线程生命周期
- 12.3 线程间通信
- 12.4 优雅关闭机制

### 十三、错误处理
- 13.1 错误分类
- 13.2 重试策略
- 13.3 错误隔离
- 13.4 日志记录

### 十四、性能优化
- 14.1 批量处理
- 14.2 限流保护
- 14.3 数据库优化
- 14.4 内存管理

## 三、资金费率同步

### 3.1 FundingRateSyncManager 设计

**类结构**：
```python
class FundingRateSyncManager(threading.Thread):
    - api_manager: APIManager  # API管理器
    - symbol: str  # 币种名称
    - ccxt_symbol: str  # CCXT格式
    - last_sync_time: datetime  # 最后同步时间
```

**初始化**：每个币种创建独立线程，线程名：`FundingRateSyncThread-{symbol}`

### 3.2 同步时机（每8小时）

**资金费率更新规则**：
- OKX资金费率每8小时更新一次
- 更新时间点：00:00, 08:00, 16:00 UTC

**同步判断逻辑**（`_should_sync`）：
1. **首次同步**：如果从未同步过，立即同步
2. **时间间隔检查**：
   - 最小间隔：至少间隔1小时才检查（避免频繁检查）
   - 如果距离上次同步超过7.5小时，需要同步（提前一点，避免错过）
3. **更新时间点检查**：
   - 在更新时间点（00:00, 08:00, 16:00）前后5分钟内
   - 检查上次同步是否在这个时间点之前
   - 如果是，则同步

**主循环**：
- 每分钟检查一次是否需要同步
- 满足条件时调用`_fetch_and_save_funding_rate()`

### 3.3 历史数据补全

**补全策略**（`_sync_initial_data`）：
1. **计算补全范围**：
   - 从配置读取开始天数（FUNDING_RATE_START_DAYS，默认30天）
   - 计算开始时间 = 当前时间 - 开始天数
   - 查询数据库最新资金费率时间

2. **判断补全策略**：
   - 如果数据库为空：从开始时间补全到当前时间
   - 如果已有数据：从最新时间 + 8小时补全到当前时间

3. **批量获取历史数据**：
   - 调用`api_manager.get_funding_rate_history()`获取历史数据
   - 最多获取100条记录
   - 解析每条记录的时间戳和资金费率

4. **数据保存**：
   - 只保存时间范围内的数据
   - 使用`FundingRateRepository.insert_funding_rate()`保存
   - 支持去重（基于symbol和time）

**数据格式**：
- `funding_time`: 资金费率结算时间（datetime）
- `funding_rate`: 资金费率（float）
- `open_interest`: 未平仓合约（可选，float）

### 3.4 数据格式说明

**API返回格式**：
```python
{
    'fundingRate': '0.0001',  # 资金费率
    'nextFundingTime': 1234567890000,  # 下次结算时间（毫秒）
    'fundingTime': '1234567890000',  # 当前结算时间（历史数据）
    'openInterest': '1000000'  # 未平仓合约（可选）
}
```

**数据库存储**：
- `symbol`: 币种名称
- `time`: 资金费率结算时间（主键之一）
- `funding_rate`: 资金费率
- `open_interest`: 未平仓合约（可选）

## 四、未平仓合约同步

### 4.1 OpenInterestSyncManager 设计

**类结构**：
```python
class OpenInterestSyncManager(threading.Thread):
    - coinglass_client: CoinGlassClient  # CoinGlass客户端
    - symbol: str  # 币种名称
    - last_sync_time: datetime  # 最后同步时间
```

**初始化**：每个币种创建独立线程，线程名：`OpenInterestSyncThread-{symbol}`

### 4.2 CoinGlass API 调用

**API方法**：`coinglass_client.get_open_interest_history()`

**参数**：
- `symbol`: 币种名称（BTC, ETH等）
- `exchange`: 交易所（"OKX"）
- `interval`: 时间间隔（"4h"用于历史数据，实时数据不指定）
- `start_time`: 开始时间（毫秒时间戳）
- `end_time`: 结束时间（毫秒时间戳）

### 4.3 同步频率和策略

**实时同步**（`_fetch_and_save_open_interest`）：
- **同步时机**：每15分钟同步一次（在00, 15, 30, 45分的前30秒内）
- **查询范围**：最近30分钟的数据
- **数据格式**：OHLC格式（open, high, low, close）

**历史数据补全**（`_sync_initial_data`）：
- **补全范围**：最近30天
- **时间间隔**：4小时间隔
- **批量保存**：使用`batch_insert_open_interest()`批量插入

**主循环**：
- 每30秒检查一次是否需要同步
- 满足条件时调用`_fetch_and_save_open_interest()`

### 4.4 数据格式说明

**API返回格式**：
```python
[
    {
        'time': 1234567890000,  # 时间戳（毫秒）
        'open': 1000000.0,  # 开盘未平仓合约
        'high': 1100000.0,  # 最高未平仓合约
        'low': 900000.0,  # 最低未平仓合约
        'close': 1050000.0  # 收盘未平仓合约
    }
]
```

**数据库存储**：
- `symbol`: 币种名称
- `time`: 时间（主键之一）
- `oi_open`: 开盘未平仓合约
- `oi_high`: 最高未平仓合约
- `oi_low`: 最低未平仓合约
- `oi_close`: 收盘未平仓合约

## 五、市场情绪同步

### 5.1 MarketSentimentSyncManager 设计

**类结构**：
```python
class MarketSentimentSyncManager(threading.Thread):
    - coinglass_client: CoinGlassClient  # CoinGlass客户端
    - symbol: str  # 币种名称
    - last_sync_time: datetime  # 最后同步时间
```

**初始化**：每个币种创建独立线程，线程名：`MarketSentimentSyncThread-{symbol}`

### 5.2 数据源和API

**API方法**：`coinglass_client.get_long_short_ratio_history()`

**参数**：
- `symbol`: 币种名称
- `exchange`: 交易所（"Binance"）
- `interval`: 时间间隔（"4h"）
- `limit`: 最多返回数量（1000）
- `start_time`: 开始时间（毫秒时间戳）
- `end_time`: 结束时间（毫秒时间戳）

### 5.3 同步策略

**同步频率**：
- 每4小时同步一次（与4h数据周期一致）
- 距离上次同步超过4小时时触发

**数据范围**：
- 每次同步获取最近30天的4h数据
- 最多返回1000条记录

**主循环**：
- 每5分钟检查一次是否需要同步
- 满足条件时调用`_fetch_and_save_sentiment()`

### 5.4 数据格式说明

**API返回格式**：
```python
[
    {
        'time': 1234567890000,  # 时间戳（毫秒）
        'global_account_long_percent': 55.5,  # 全球账户做多比例
        'global_account_short_percent': 44.5,  # 全球账户做空比例
        'global_account_long_short_ratio': 1.25  # 全球账户多空比
    }
]
```

**数据库存储**：
- `symbol`: 币种名称
- `time`: 时间（主键之一）
- `global_account_long_percent`: 做多比例
- `global_account_short_percent`: 做空比例
- `global_account_long_short_ratio`: 多空比

## 六、盘口挂单同步

### 6.1 OrderBookSyncManager 设计

**类结构**：
```python
class OrderBookSyncManager(threading.Thread):
    - api_manager: APIManager  # API管理器
    - symbol: str  # 币种名称
    - ccxt_symbol: str  # CCXT格式
    - last_sync_time: datetime  # 最后同步时间
```

**初始化**：每个币种创建独立线程，线程名：`OrderBookSyncThread-{symbol}`

### 6.2 OKX API 调用

**API端点**：`/api/v5/market/books-full`

**参数**：
- `instId`: 产品ID（如BTC-USDT-SWAP）
- `sz`: 返回深度档数（1000档）

**格式转换**：
- CCXT格式：`BTC/USDT:USDT`
- OKX格式：`BTC-USDT-SWAP`
- 转换逻辑：`replace('/', '-').replace(':USDT', '-SWAP')`

### 6.3 同步频率

**同步频率**：每1小时同步一次

**判断逻辑**：
- 如果从未同步过，立即同步
- 距离上次同步超过1小时，需要同步

**主循环**：
- 每5分钟检查一次是否需要同步
- 满足条件时调用`_fetch_and_save_order_book()`

### 6.4 数据格式说明

**API返回格式**：
```python
{
    'asks': [  # 卖单列表
        ['价格', '数量', '订单数'],  # 每档3个字段
        ...
    ],
    'bids': [  # 买单列表
        ['价格', '数量', '订单数'],
        ...
    ]
}
```

**大单计算**：
- **卖单大单**：档位数量超过平均档位数量的2倍
- **买单大单**：档位数量超过平均档位数量的2倍
- 用于分析大单压力/支撑

**数据库存储**：
- `symbol`: 币种名称
- `time`: 时间（主键之一）
- `asks`: 卖单列表（JSON格式）
- `bids`: 买单列表（JSON格式）
- `large_ask_amount`: 大卖单总金额（可选）
- `large_bid_amount`: 大买单总金额（可选）

## 七、ETF资金流同步

### 7.1 ETFFlowSyncManager 设计

**类结构**：
```python
class ETFFlowSyncManager(threading.Thread):
    - coinglass_client: CoinGlassClient  # CoinGlass客户端
    - symbol: str  # 币种名称（仅BTC/ETH）
    - last_sync_date: date  # 最后同步日期
```

**初始化**：仅BTC和ETH创建线程，线程名：`ETFFlowSyncThread-{symbol}`

### 7.2 支持币种（BTC/ETH）

**限制**：ETF资金流数据仅支持BTC和ETH两个币种

**原因**：CoinGlass API仅提供这两个币种的ETF资金流数据

### 7.3 同步时机（每天8点）

**同步时机**：每天早上8点（UTC）同步

**判断逻辑**（`_should_sync`）：
- 小时数 == 8 且 分钟数 < 5

**主循环**：
- 每5分钟检查一次是否需要同步
- 满足条件时调用`_fetch_and_save_etf_flow()`

### 7.4 数据格式说明

**API返回格式**：
```python
[
    {
        'timestamp': 1234567890000,  # 时间戳（毫秒）
        'net_assets_usd': 1000000000.0,  # 净资产（USD）
        'change_usd': 10000000.0  # 变化金额（USD）
    }
]
```

**数据库存储**：
- `symbol`: 币种名称（BTC/ETH）
- `date`: 日期（主键之一）
- `net_assets_usd`: 净资产（USD）
- `change_usd`: 变化金额（USD）
- `timestamp`: 时间戳（毫秒）

**错误处理**：
- API返回None：记录警告（可能是API错误或需要升级计划）
- 数据为空：记录警告
- 字段缺失：跳过该条数据，继续处理下一条

## 八、恐惧贪婪指数同步

### 8.1 FearGreedSyncManager 设计

**类结构**：
```python
class FearGreedSyncManager(threading.Thread):
    - coinglass_client: CoinGlassClient  # CoinGlass客户端
    - last_sync_date: date  # 最后同步日期
```

**初始化**：全局唯一实例，线程名：`FearGreedSyncThread`

### 8.2 全局唯一实例

**设计原因**：
- 恐惧贪婪指数是全局市场指标，不区分币种
- 避免重复同步，节省资源

**初始化位置**：在`main.py`中创建唯一实例

### 8.3 同步策略

**同步时机**：每天早上8点（UTC）同步

**判断逻辑**：
- 小时数 == 8 且 分钟数 < 5

**主循环**：
- 每5分钟检查一次是否需要同步
- 满足条件时调用`_fetch_and_save_fear_greed()`

### 8.4 数据格式说明

**API返回格式**：
```python
{
    'data_list': [25, 30, 35, ...],  # 恐惧贪婪指数值列表（0-100）
    'price_list': [30000.0, 31000.0, ...],  # 价格列表
    'time_list': [1234567890000, ...]  # 时间戳列表（毫秒）
}
```

**数据验证**：
- 检查三个列表是否存在
- 检查列表类型和长度
- 确保三个数组长度一致（取最小值）

**数据库存储**：
- `time`: 日期（主键）
- `value`: 恐惧贪婪指数值（0-100）
- `price`: 价格

**事务处理**：
- 每条记录使用独立事务，减少死锁风险
- 单条失败不影响其他记录

## 九、爆仓历史同步

### 9.1 LiquidationSyncManager 设计

**类结构**：
```python
class LiquidationSyncManager(threading.Thread):
    - coinglass_client: CoinGlassClient  # CoinGlass客户端
    - symbol: str  # 币种名称
    - last_sync_time: datetime  # 最后同步时间
```

**初始化**：每个币种创建独立线程，线程名：`LiquidationSyncThread-{symbol}`

### 9.2 同步策略

**同步频率**：每4小时同步一次

**判断逻辑**：
- 如果从未同步过，立即同步
- 距离上次同步超过4小时，需要同步

**数据范围**：
- 每次同步获取最近30天的数据
- 时间间隔：4小时
- 最多返回1000条记录

**主循环**：
- 每5分钟检查一次是否需要同步
- 满足条件时调用`_fetch_and_save_liquidation()`

### 9.3 数据格式说明

**API返回格式**：
```python
[
    {
        'time': 1234567890000,  # 时间戳（毫秒）
        'aggregated_long_liquidation_usd': 1000000.0,  # 做多爆仓总额（USD）
        'aggregated_short_liquidation_usd': 500000.0  # 做空爆仓总额（USD）
    }
]
```

**数据库存储**：
- `symbol`: 币种名称
- `time`: 时间（主键之一）
- `aggregated_long_liquidation_usd`: 做多爆仓总额（USD）
- `aggregated_short_liquidation_usd`: 做空爆仓总额（USD）

## 十、订单历史同步

### 10.1 OrderHistorySyncManager 设计

**类结构**：
```python
class OrderHistorySyncManager(threading.Thread):
    - api_manager: APIManager  # API管理器
    - orders_websocket_client: OKXOrdersWebSocketClient  # WebSocket客户端（可选）
    - last_sync_time: datetime  # 最后同步时间
    - sync_symbols: List[str]  # 要同步的币种列表
    - time_window_minutes: int  # 时间窗口（5分钟前）
    - sync_interval: int  # 同步间隔（300秒）
```

**初始化**：全局唯一实例，线程名：`OrderHistorySyncThread`

**币种列表**：从配置读取（OKX_ORDER_HISTORY_SYMBOLS），默认BTC,ETH

### 10.2 实时同步策略

**同步频率**：每30秒同步一次（可配置）

**时间窗口**：
- 只拉取5分钟前的数据，避免与WebSocket重叠
- WebSocket负责实时订单（最近5分钟）
- 历史同步负责5分钟前的订单

**同步范围**：
- 所有配置的币种
- 只同步永续合约（SWAP）
- 只查询市价单（market）
- 只查询完全成交的订单（filled）

### 10.3 历史数据补全

**补全策略**：
1. **首次同步检查**：
   - 检查每个币种是否有历史数据
   - 如果没有，执行首次同步

2. **首次同步流程**（`_sync_symbol_initial`）：
   - 从配置读取开始时间（OKX_ORDER_HISTORY_START_TIME）
   - 如果未配置，默认从30天前开始
   - 分页获取历史订单，直到获取完所有数据

3. **增量同步**：
   - 从数据库最新订单时间开始
   - 同步到当前时间（减去时间窗口）

### 10.4 与WebSocket协调

**协调机制**：
- 检查WebSocket状态（如果提供）
- 如果WebSocket正常，只同步5分钟前的数据
- 如果WebSocket异常，扩大同步范围

**避免重复**：
- 基于订单ID去重
- 数据库使用`ON CONFLICT`处理重复

### 10.5 去重机制

**去重键**：订单ID（`ord_id`）

**去重方式**：
- 数据库层面：使用`ON CONFLICT (ord_id) DO NOTHING`
- 应用层面：查询时检查订单是否已存在

### 10.6 多币种同步

**同步流程**（`_sync_all_symbols`）：
1. 遍历所有配置的币种
2. 对每个币种执行同步：
   - 查询数据库最新订单时间
   - 计算需要同步的时间范围
   - 分页获取订单数据
   - 保存到数据库
3. 更新最后同步时间

**错误隔离**：
- 单个币种失败不影响其他币种
- 记录错误日志，继续处理下一个币种

**API调用**：
- 直接调用OKX原始API（`/api/v5/trade/orders-history-archive`）
- 避免通过APIManager队列，防止时间戳过期
- 需要手动构建签名和请求头

## 十一、仓位历史同步

### 11.1 PositionHistorySyncManager 设计

**类结构**：
```python
class PositionHistorySyncManager(threading.Thread):
    - api_manager: APIManager  # API管理器
    - last_sync_time: datetime  # 最后同步时间
    - sync_symbols: List[str]  # 要同步的币种列表
```

**初始化**：全局唯一实例，线程名：`PositionHistorySyncThread`

**币种列表**：从配置读取（OKX_POSITION_HISTORY_SYMBOLS），默认BTC,ETH

### 11.2 实时同步策略

**同步频率**：每30秒同步一次

**同步范围**：
- 所有配置的币种
- 只同步永续合约（SWAP）

**同步流程**（`_sync_all_symbols`）：
1. 遍历所有配置的币种
2. 对每个币种执行同步：
   - 查询数据库最新仓位时间（`u_time`）
   - 使用`before`参数获取更新的仓位
   - 分页获取仓位数据
   - 保存到数据库
3. 更新最后同步时间

### 11.3 历史数据补全

**补全策略**：
1. **首次同步检查**：
   - 检查每个币种是否有历史数据
   - 如果没有，执行首次同步

2. **首次同步流程**（`_sync_symbol_initial`）：
   - 从配置读取开始时间（OKX_POSITION_HISTORY_START_TIME）
   - 如果未配置，默认从30天前开始
   - 分页获取历史仓位，直到获取完所有数据

3. **增量同步**：
   - 从数据库最新仓位时间开始
   - 使用`before`参数向前获取更新的仓位

### 11.4 多币种同步

**同步流程**：
- 遍历所有配置的币种
- 对每个币种独立同步
- 错误隔离：单个币种失败不影响其他币种

**API调用**：
- 直接调用OKX原始API（`/api/v5/account/positions-history`）
- 需要手动构建签名和请求头
- 使用分页参数（`after`/`before`）获取数据

**数据格式**：
- `pos_id`: 仓位ID
- `u_time`: 更新时间（毫秒时间戳，主键之一）
- `pos_size`: 仓位大小
- `avg_price`: 平均价格
- `unrealized_pnl`: 未实现盈亏
- `margin`: 保证金
- `leverage`: 杠杆倍数

## 十二、线程模型

### 12.1 线程设计原则

**设计原则**：
1. **独立线程**：每个同步任务使用独立线程，互不干扰
2. **非守护线程**：所有同步线程设置为`daemon=False`，确保主程序退出时线程正常结束
3. **线程命名**：使用有意义的线程名，便于日志追踪和调试
4. **线程安全**：使用`threading.Event`控制线程停止，保证线程安全

**线程命名规范**：
- K线同步：`KlineSyncThread-{symbol}`
- 资金费率同步：`FundingRateSyncThread-{symbol}`
- 未平仓合约同步：`OpenInterestSyncThread-{symbol}`
- 市场情绪同步：`MarketSentimentSyncThread-{symbol}`
- 盘口挂单同步：`OrderBookSyncThread-{symbol}`
- ETF资金流同步：`ETFFlowSyncThread-{symbol}`
- 恐惧贪婪指数同步：`FearGreedSyncThread`（全局唯一）
- 爆仓历史同步：`LiquidationSyncThread-{symbol}`
- 订单历史同步：`OrderHistorySyncThread`（全局唯一）
- 仓位历史同步：`PositionHistorySyncThread`（全局唯一）

### 12.2 线程生命周期

**线程创建**：
- 在`main.py`的`startup()`事件中创建
- 创建后立即调用`start()`启动线程
- 线程启动后执行`run()`方法

**线程运行**：
- `run()`方法包含主循环
- 主循环检查`stop_event`标志
- 满足同步条件时执行同步操作
- 循环间隔根据同步频率设置（1秒到5分钟不等）

**线程停止**：
- 调用`stop()`方法设置`stop_event`
- 主循环检测到`stop_event`后退出
- 在`shutdown()`事件中调用`join(timeout=5)`等待线程结束
- 如果5秒内未结束，记录警告日志

### 12.3 线程间通信

**通信方式**：
1. **共享数据库**：所有线程通过数据库共享数据
2. **APIManager队列**：通过APIManager的优先级队列协调API请求
3. **全局变量**：通过全局管理器字典（如`kline_sync_managers`）管理线程实例

**线程隔离**：
- 每个线程独立运行，不直接通信
- 通过数据库和APIManager间接协调
- 避免线程间直接依赖

### 12.4 优雅关闭机制

**关闭流程**（在`main.py`的`shutdown()`事件中）：
1. **停止顺序**：
   - 先停止全局唯一线程（订单历史、仓位历史、恐惧贪婪指数）
   - 再停止每个币种的同步线程（按类型分组）
   - 最后关闭WebSocket和API管理器

2. **停止步骤**：
   ```python
   # 1. 设置停止标志
   manager.stop()  # 设置stop_event
   
   # 2. 等待线程结束
   manager.join(timeout=5)  # 最多等待5秒
   
   # 3. 检查是否成功停止
   if manager.is_alive():
       logger.warning("线程未在5秒内停止")
   else:
       logger.info("线程已停止")
   ```

3. **错误处理**：
   - 每个线程的停止操作使用try-except包裹
   - 单个线程停止失败不影响其他线程
   - 记录详细的错误日志

4. **超时处理**：
   - 默认超时时间：5秒
   - 超时后记录警告，继续关闭其他线程
   - 不强制终止线程，避免数据丢失

## 十三、错误处理

### 13.1 错误分类

**网络错误**：
- **连接超时**：API请求超时（默认30秒）
- **网络中断**：网络连接断开
- **DNS解析失败**：域名解析失败
- **处理方式**：通过APIManager自动重试（最多3次）

**API错误**：
- **4xx错误**：客户端错误（参数错误、认证失败等）
  - 处理方式：记录错误日志，不重试
- **5xx错误**：服务器错误
  - 处理方式：自动重试（最多3次）
- **限流错误**：API请求频率过高
  - 处理方式：通过APIManager限流保护，自动重试

**数据错误**：
- **数据为空**：API返回空列表或None
  - 处理方式：记录警告日志，返回False，继续下次同步
- **数据格式错误**：API返回数据格式不符合预期
  - 处理方式：记录警告日志，跳过当前数据，继续处理下一条
- **数据缺失**：必需字段缺失
  - 处理方式：记录警告日志，跳过当前数据

**数据库错误**：
- **连接失败**：数据库连接异常
  - 处理方式：记录错误日志，等待后重试
- **插入失败**：数据插入异常（可能是重复数据）
  - 处理方式：使用`ON CONFLICT`处理重复，记录警告日志
- **查询失败**：数据查询异常
  - 处理方式：记录错误日志，使用默认值或跳过

### 13.2 重试策略

**APIManager重试**：
- **重试条件**：网络异常、超时、5xx错误
- **不重试条件**：4xx错误（客户端错误）
- **最大重试次数**：3次（可配置：API_MAX_RETRIES）
- **重试间隔**：立即重试（由APIManager控制）

**同步循环重试**：
- **异常后等待**：同步循环异常后等待一段时间再继续
  - K线同步：等待10秒
  - 资金费率同步：等待5分钟
  - 其他同步：等待1分钟到5分钟不等
- **避免无限重试**：每次异常后等待，避免频繁重试

**历史数据补全重试**：
- **单批失败**：跳过当前批次，继续下一批
- **整体失败**：记录错误日志，不阻塞启动流程

### 13.3 错误隔离

**线程隔离**：
- 每个同步线程独立运行
- 单个线程异常不影响其他线程
- 使用try-except包裹主循环，确保线程不崩溃

**币种隔离**：
- 每个币种独立同步线程
- 单个币种同步失败不影响其他币种
- 多币种同步时，单币种失败继续处理下一个

**数据隔离**：
- 单条数据错误不影响其他数据
- 使用continue跳过错误数据
- 批量操作时，单条失败不影响整体

### 13.4 日志记录

**日志级别**：
- **DEBUG**：详细的调试信息（数据内容、中间状态等）
- **INFO**：正常操作信息（同步成功、数据保存等）
- **WARNING**：警告信息（数据为空、格式错误、重复数据等）
- **ERROR**：错误信息（同步失败、异常等，包含完整堆栈）

**日志内容**：
- **成功操作**：记录同步成功、保存数量等
- **警告信息**：记录数据问题、格式错误等
- **错误信息**：记录异常详情、堆栈信息、上下文信息

**日志格式**：
- 包含时间戳、日志级别、模块名、消息内容
- 错误日志包含完整堆栈信息（`exc_info=True`）
- 关键操作包含币种、时间等上下文信息

## 十四、性能优化

### 14.1 批量处理

**批量获取**：
- K线历史补全：每次最多200根K线
- 订单历史同步：每次最多100条订单
- 仓位历史同步：每次最多100条仓位
- 减少API调用次数，提高效率

**批量保存**：
- 使用`batch_insert_*`方法批量插入
- 减少数据库事务次数
- 提高数据库写入性能

**批量计算**：
- 技术指标批量计算（`batch_update_all_indicators`）
- 减少数据库查询次数
- 提高计算效率

### 14.2 限流保护

**APIManager限流**：
- 速率限制：每2秒最多10次请求（可配置）
- 最小间隔：每次请求间隔至少200ms（可配置）
- 时间窗口算法：滑动时间窗口，精确控制请求频率

**同步频率控制**：
- 根据数据更新频率设置同步间隔
- K线同步：每秒检查，但只在K线收盘时同步
- 其他同步：1分钟到5分钟检查一次
- 避免不必要的API调用

**请求间隔**：
- 批量获取时，每批之间等待0.5秒
- 避免请求过快触发API限流

### 14.3 数据库优化

**索引优化**：
- 主键索引：所有表都有主键索引
- 时间索引：时间字段建立索引，加快查询
- 复合索引：常用查询字段建立复合索引

**查询优化**：
- 使用`LIMIT`限制查询数量
- 使用时间范围查询，避免全表扫描
- 使用`ORDER BY`和索引，加快排序

**插入优化**：
- 使用`ON CONFLICT`处理重复，避免先查询再插入
- 批量插入，减少事务次数
- 使用`INSERT ... ON CONFLICT DO NOTHING`，避免重复检查

**连接池**：
- 使用SQLAlchemy连接池
- 复用数据库连接，减少连接开销
- 合理设置连接池大小

### 14.4 内存管理

**数据缓存**：
- 同步状态缓存：`last_sync_time`等状态信息
- 避免频繁查询数据库

**队列大小限制**：
- WebSocket消息队列：最大100-200条
- 避免内存无限增长
- 队列满时丢弃旧数据或阻塞

**数据清理**：
- WebSocket去重记录：保留最近30分钟
- 定期清理过期记录，释放内存

**批量处理**：
- 分批处理大量数据，避免一次性加载到内存
- 使用生成器或迭代器，减少内存占用

## 十五、配置说明

### 15.1 同步频率配置

**K线同步配置**：
- `KLINE_15M_START_DAYS`：15分钟K线初始同步天数（默认30天）
- `KLINE_4H_START_DAYS`：4小时K线初始同步天数（默认180天）
- `KLINE_1D_START_DAYS`：日线K线初始同步天数（默认600天）

**资金费率同步配置**：
- `FUNDING_RATE_START_DAYS`：资金费率初始同步天数（默认30天）
- 同步频率：每8小时（固定，不可配置）

**其他同步配置**：
- 未平仓合约：每15分钟（固定）
- 市场情绪：每4小时（固定）
- 盘口挂单：每1小时（固定）
- ETF资金流：每天8点（固定）
- 恐惧贪婪指数：每天8点（固定）
- 爆仓历史：每4小时（固定）
- 订单历史：每30秒（可配置：`OKX_ORDER_HISTORY_SYMBOLS`）
- 仓位历史：每30秒（可配置：`OKX_POSITION_HISTORY_SYMBOLS`）

### 15.2 历史数据补全配置

**补全范围配置**：
- 通过`*_START_DAYS`配置项控制初始同步天数
- 系统启动时自动补全配置天数内的历史数据

**补全策略**：
- 智能补全：检测数据库已有数据，只补全缺失部分
- 断点续传：检测时间序列断点，自动补全
- 增量补全：从最新数据时间开始，补全到当前时间

**订单/仓位历史补全配置**：
- `OKX_ORDER_HISTORY_START_TIME`：订单历史开始时间（毫秒时间戳）
- `OKX_POSITION_HISTORY_START_TIME`：仓位历史开始时间（毫秒时间戳）
- 如果未配置，默认从30天前开始

### 15.3 重试配置

**API重试配置**：
- `API_MAX_RETRIES`：最大重试次数（默认3次）
- `API_REQUEST_TIMEOUT`：请求超时时间（默认30秒）

**重试策略**：
- 网络异常、超时、5xx错误：自动重试
- 4xx错误：不重试（客户端错误）
- 重试间隔：立即重试（由APIManager控制）

**同步循环重试**：
- 异常后等待时间：根据同步类型不同（10秒到5分钟）
- 避免频繁重试，给系统恢复时间

### 15.4 超时配置

**API超时配置**：
- `API_REQUEST_TIMEOUT`：API请求超时时间（默认30秒）
- 超过此时间无响应则认为请求失败

**线程关闭超时**：
- 默认超时时间：5秒
- 在`shutdown()`事件中等待线程结束
- 超时后记录警告，继续关闭其他线程

**WebSocket超时配置**：
- `WS_CONNECT_TIMEOUT`：连接超时时间（默认30秒）
- `WS_SUBSCRIBE_TIMEOUT`：订阅超时时间（默认30秒）
- `WS_PING_TIMEOUT`：ping超时时间（默认5秒）
- `WS_PRICE_TIMEOUT`：价格更新超时时间（默认30秒）

### 15.5 其他配置

**币种配置**：
- `TRADING_SYMBOLS`：交易币种列表（逗号分隔，如"BTC,ETH"）
- `OKX_ORDER_HISTORY_SYMBOLS`：订单历史同步币种（默认"BTC,ETH"）
- `OKX_POSITION_HISTORY_SYMBOLS`：仓位历史同步币种（默认"BTC,ETH"）

**API限流配置**：
- `API_RATE_LIMIT`：速率限制（默认每2秒10次）
- `API_RATE_WINDOW`：限流时间窗口（默认2.0秒）
- `API_MIN_INTERVAL`：最小请求间隔（默认0.2秒）

**配置读取**：
- 所有配置从数据库`config`表读取
- 如果数据库不可用，使用默认值
- 配置修改后立即生效（无需重启）

