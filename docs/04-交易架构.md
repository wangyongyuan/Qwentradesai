# 交易架构文档

## 一、概述

### 1.1 交易模块职责

交易模块是系统的核心执行模块，负责执行交易操作和管理持仓。

**主要职责**：
- 开仓、加仓、减仓、平仓操作
- 止损止盈管理（OKX Algo Order）
- 订单状态追踪和管理
- 持仓状态管理
- 外部平仓检测和处理
- 挂单管理（价格触发开仓）

**设计特点**：
- **单持仓限制**：同一币种只能有一个活跃持仓
- **clOrdId复用**：加仓、减仓、平仓复用原clOrdId，便于追踪
- **自动止损止盈**：开仓时自动创建止损止盈条件单
- **外部平仓处理**：自动检测和处理外部平仓（手动平仓、爆仓等）

### 1.2 核心组件

**TradingManager**：
- 交易执行管理器
- 负责所有交易操作（开仓、加仓、减仓、平仓）
- 管理持仓状态和订单状态

**PendingOrderManager**：
- 挂单管理器
- 管理价格触发挂单
- 监控挂单状态和过期

**ClOrdIdGenerator**：
- 客户端订单ID生成器
- 生成唯一订单ID（符合OKX要求）

### 1.3 设计理念

**安全性优先**：
- 严格的参数验证
- 持仓状态检查
- 止损止盈必须设置
- 杠杆限制检查

**状态一致性**：
- 内存状态与数据库状态同步
- 内存状态与OKX实际持仓同步
- 自动修复状态不一致

**可追溯性**：
- 所有操作记录到trading_relations表
- 关联订单ID和信号ID
- 记录操作类型和数量

## 二、TradingManager 设计

### 2.1 类结构

**核心属性**：
- `api_manager`: APIManager - API管理器（依赖注入）
- `db`: Database - 数据库连接
- `trading_relations_repo`: TradingRelationsRepository - 交易关系Repository
- `market_signal_repo`: MarketSignalRepository - 市场信号Repository
- `cl_ord_id_generator`: ClOrdIdGenerator - 订单ID生成器
- `current_cl_ord_id`: Optional[str] - 当前持仓的clOrdId（内存状态）
- `current_position_side`: Optional[str] - 当前持仓方向（LONG/SHORT）
- `current_position_amount`: Optional[float] - 当前持仓数量（内存状态）

**状态管理**：
- 使用内存变量追踪当前持仓状态
- 定期与OKX API和数据库同步
- 支持状态自动修复

### 2.2 依赖注入

**APIManager注入**：
- 通过构造函数注入
- 用于所有API调用（下单、查询等）
- 统一限流和重试管理

**初始化代码**：
```python
def __init__(self, api_manager: APIManager):
    if api_manager is None:
        raise ValueError("api_manager不能为None")
    self.api_manager = api_manager
    self.db = db
    # ... 其他初始化
```

### 2.3 初始化流程

1. **验证依赖**：检查api_manager不为None
2. **初始化数据库连接**：验证数据库连接
3. **初始化Repository**：创建Repository实例
4. **初始化ClOrdIdGenerator**：创建订单ID生成器
5. **初始化状态变量**：current_cl_ord_id等设为None

## 三、开仓功能

### 3.1 open_position 方法

**方法签名**：
```python
def open_position(
    self,
    symbol: str,
    side: str,  # LONG/SHORT
    amount: float,
    stop_loss_trigger: float,
    take_profit_trigger: float,
    leverage: float,
    signal_id: int
) -> str  # 返回clOrdId
```

**3.1.1 参数验证**：
- `symbol`：不能为空，转换为大写
- `side`：必须是LONG或SHORT
- `amount`：必须大于0
- `stop_loss_trigger`：必须大于0
- `take_profit_trigger`：必须大于0
- `leverage`：必须大于0，且不超过最大杠杆（MAX_LEVERAGE，默认10）
- `signal_id`：必须大于0

**3.1.2 持仓检查**：
- **检查内存状态**：`has_active_position()`
- **兜底检查**：如果内存中有clOrdId，查询OKX API实际持仓
  - 如果实际持仓为0，清除内存状态，允许开仓
  - 如果实际有持仓，抛出异常，拒绝开仓
- **设计考虑**：防止状态不一致导致的开仓错误

**3.1.3 数量计算**：
- **获取合约信息**：从CCXT market获取`contractSize`
- **数量转换**：币数量 → 合约张数
  - 公式：`contracts = amount / contract_size`
  - 四舍五入到0.1精度
- **默认合约乘数**：
  - ETH：0.1
  - 其他：1.0

**3.1.4 订单提交**：
- **生成clOrdId**：使用`ClOrdIdGenerator.generate()`
- **构建OKX API参数**：
  - `instId`：产品ID（如ETH-USDT-SWAP）
  - `tdMode`：'cross'（全仓模式）
  - `side`：'buy'（LONG）或'sell'（SHORT）
  - `ordType`：'market'（市价单）
  - `sz`：合约张数
  - `posSide`：'long'或'short'
  - `lever`：杠杆倍数
  - `clOrdId`：客户端订单ID
  - `attachAlgoOrds`：止损止盈条件单（见3.1.5）
- **调用API**：通过APIManager提交（优先级：TRADE）
- **保存订单ID**：更新内存状态（`_set_current_cl_ord_id()`）

**3.1.5 止损止盈创建**：
- **创建方式**：使用OKX的`attachAlgoOrds`参数，开仓时同时创建
- **条件单格式**：
  ```python
  {
      'tpTriggerPx': str(take_profit_trigger),  # 止盈触发价格
      'tpTriggerPxType': 'last',  # 使用最新价格触发
      'tpOrdPx': '-1',  # 市价单
      'slTriggerPx': str(stop_loss_trigger),  # 止损触发价格
      'slTriggerPxType': 'last',  # 使用最新价格触发
      'slOrdPx': '-1',  # 市价单
      'attachAlgoClOrdId': attach_algo_cl_ord_id  # 策略订单ID
  }
  ```
- **策略订单ID生成**：`algo` + clOrdId后缀（最多28位）

**3.1.6 交易关系记录**：
- **记录到trading_relations表**：
  - `signal_id`：信号ID
  - `cl_ord_id`：客户端订单ID
  - `operation_type`：'open'（开仓）
  - `ord_id`：订单ID（从API返回）
  - `amount`：实际成交数量（从order_history查询）
  - `price`：成交价格

### 3.2 开仓流程

**完整流程**：
```
1. 参数验证
   ↓
2. 持仓检查（内存状态 + OKX API兜底）
   ↓
3. 获取当前价格
   ↓
4. 验证止损止盈价格（相对于当前价格）
   ↓
5. 生成clOrdId
   ↓
6. 转换数量（币数量 → 合约张数）
   ↓
7. 构建OKX API参数（包含止损止盈）
   ↓
8. 调用API下单（通过APIManager）
   ↓
9. 更新内存状态（保存clOrdId、持仓方向、数量）
   ↓
10. 记录交易关系（trading_relations表）
```

**止损止盈验证**：
- **做多**：止损 < 当前价格 < 止盈
- **做空**：止盈 < 当前价格 < 止损
- 验证失败抛出ValueError

### 3.3 错误处理

**参数验证错误**：
- 抛出`ValueError`，包含详细错误信息
- 不调用API，避免无效请求

**持仓检查错误**：
- 如果已有持仓，抛出`RuntimeError`
- 兜底检查失败时，记录警告但继续尝试开仓

**API调用错误**：
- 通过APIManager自动重试
- 如果最终失败，抛出`RuntimeError`
- 记录详细错误日志

## 四、加仓功能

### 4.1 add_position 方法

**方法签名**：
```python
def add_position(
    self,
    cl_ord_id: str,
    amount: float
) -> bool
```

**4.1.1 持仓验证**：
- 检查内存状态：`has_active_position() and current_cl_ord_id == cl_ord_id`
- 从数据库查询关联信息，获取symbol和signal_id
- 验证失败抛出`RuntimeError`

**4.1.2 加仓数量验证**：
- `amount`必须大于0
- 数量转换：币数量 → 合约张数（与开仓相同逻辑）

**4.1.3 止损止盈更新**：
- **当前实现**：加仓时不自动更新止损止盈
- **设计考虑**：加仓后可能需要调整止损止盈，但由用户手动调用`set_stop_loss_take_profit()`

**4.1.4 订单提交**：
- **复用clOrdId**：使用原clOrdId，便于追踪
- **同方向**：加仓方向与持仓方向相同
- **API参数**：与开仓类似，但复用clOrdId
- **记录交易关系**：`operation_type='add'`

### 4.2 加仓流程

**完整流程**：
```
1. 参数验证
   ↓
2. 持仓验证（内存状态 + 数据库查询）
   ↓
3. 获取持仓方向（从内存状态）
   ↓
4. 从数据库查询symbol和杠杆
   ↓
5. 转换数量（币数量 → 合约张数）
   ↓
6. 获取当前价格
   ↓
7. 构建OKX API参数（复用clOrdId，同方向）
   ↓
8. 调用API下单
   ↓
9. 更新内存状态（更新持仓数量）
   ↓
10. 记录交易关系（operation_type='add'）
```

### 4.3 错误处理

**持仓验证错误**：
- 如果没有活跃持仓或clOrdId不匹配，抛出`RuntimeError`
- 记录详细错误信息

**数量查询错误**：
- 从order_history查询实际成交数量
- 如果查询失败，使用请求数量作为fallback

## 五、减仓功能

### 5.1 reduce_position 方法

**方法签名**：
```python
def reduce_position(
    self,
    cl_ord_id: str,
    amount: float
) -> bool
```

**5.1.1 持仓验证**：
- 检查内存状态：`has_active_position() and current_cl_ord_id == cl_ord_id`
- 从数据库查询关联信息
- 验证失败抛出`RuntimeError`

**5.1.2 减仓数量验证**：
- `amount`必须大于0
- 从OKX API查询当前持仓数量
- 验证：减仓数量不能超过当前持仓数量
- 如果减仓数量 >= 当前持仓数量，自动调整为全部平仓

**5.1.3 订单提交**：
- **复用clOrdId**：使用原clOrdId
- **反向平仓**：方向与持仓方向相反
- **API参数**：与平仓类似，但数量为减仓数量
- **记录交易关系**：`operation_type='reduce'`

**5.1.4 交易关系更新**：
- 记录减仓操作到trading_relations表
- 更新内存状态（减少持仓数量）
- 如果减仓后数量为0，清除内存状态

### 5.2 减仓流程

**完整流程**：
```
1. 参数验证
   ↓
2. 持仓验证
   ↓
3. 从OKX API查询当前持仓数量
   ↓
4. 验证减仓数量（不能超过当前持仓）
   ↓
5. 转换数量（币数量 → 合约张数）
   ↓
6. 构建OKX API参数（复用clOrdId，反向平仓）
   ↓
7. 调用API下单
   ↓
8. 更新内存状态（减少持仓数量）
   ↓
9. 记录交易关系（operation_type='reduce'）
```

### 5.3 错误处理

**数量验证错误**：
- 如果减仓数量超过持仓数量，自动调整为全部平仓
- 记录警告日志

**API调用错误**：
- 通过APIManager自动重试
- 记录详细错误日志

## 六、平仓功能

### 6.1 close_position 方法

**方法签名**：
```python
def close_position(
    self,
    cl_ord_id: str,
    amount: Optional[float] = None,  # None=全部平仓
    is_system_call: bool = True
) -> bool
```

**6.1.1 持仓检查**：
- 检查内存状态：`has_active_position() and current_cl_ord_id == cl_ord_id`
- 从OKX API查询当前持仓（保证实时）
- 获取持仓信息：`pos_size`、`pos_side`、`pos_id`

**6.1.2 条件单取消**：
- **查询所有条件单**：通过OKX API查询该持仓的所有策略订单
- **取消所有条件单**：取消所有相关的止损止盈条件单
- **错误处理**：如果取消失败，记录警告但继续平仓

**6.1.3 平仓数量计算**：
- **全部平仓**：如果`amount is None`，使用当前持仓数量
- **部分平仓**：如果`amount`指定，使用指定数量
- **自动调整**：如果`amount >= 当前持仓`，自动调整为全部平仓
- **方法**：`_determine_close_amount()`

**6.1.4 订单提交**：
- **反向平仓**：方向与持仓方向相反
- **复用clOrdId**：使用原clOrdId
- **API参数**：与开仓类似，但方向相反
- **记录交易关系**：`operation_type='close'`或`'reduce'`

**6.1.5 盈亏计算**：
- **计算方式**：
  - 查询所有开仓订单的平均价格
  - 查询所有平仓订单的平均价格
  - 计算盈亏：`pnl = (平仓价格 - 开仓价格) × 数量 × 方向系数`
  - 计算盈亏百分比：`pnl_percentage = (pnl / 开仓成本) × 100`
- **更新trading_relations**：记录盈亏信息

**6.1.6 交易关系更新**：
- **全部平仓**：
  - `operation_type='close'`
  - 更新`close_order_id`、`close_time`
  - 标记为已平仓（`status='closed'`）
  - 清除内存状态（`_clear_current_cl_ord_id()`）
- **部分平仓**：
  - `operation_type='reduce'`
  - 更新持仓数量
  - 不标记为已平仓

### 6.2 平仓流程

**完整流程**：
```
1. 参数验证
   ↓
2. 持仓检查（内存状态 + OKX API查询）
   ↓
3. 取消所有条件单（止损止盈）
   ↓
4. 计算平仓数量（全部/部分）
   ↓
5. 转换数量（币数量 → 合约张数）
   ↓
6. 构建OKX API参数（复用clOrdId，反向平仓）
   ↓
7. 调用API下单
   ↓
8. 计算盈亏（查询开仓和平仓价格）
   ↓
9. 更新交易关系（记录平仓信息、盈亏）
   ↓
10. 更新内存状态（全部平仓时清除，部分平仓时减少数量）
```

### 6.3 部分平仓 vs 全部平仓

**全部平仓**：
- **触发条件**：`amount is None`或`amount >= 当前持仓`
- **处理**：
  - 取消所有条件单
  - 平仓全部数量
  - 计算盈亏
  - 清除内存状态
  - 标记为已平仓

**部分平仓**：
- **触发条件**：`amount < 当前持仓`
- **处理**：
  - 取消所有条件单（可选，也可以保留）
  - 平仓指定数量
  - 更新持仓数量
  - 不标记为已平仓
  - 更新内存状态（减少数量）

### 6.4 错误处理

**持仓检查错误**：
- 如果没有活跃持仓，抛出`RuntimeError`
- 如果clOrdId不匹配，抛出`RuntimeError`

**条件单取消错误**：
- 如果取消失败，记录警告但继续平仓
- 不影响平仓流程

**盈亏计算错误**：
- 如果查询失败，记录警告
- 不阻止平仓流程

## 七、止损止盈管理

### 7.1 set_stop_loss_take_profit 方法

**方法签名**：
```python
def set_stop_loss_take_profit(
    self,
    cl_ord_id: str,
    plans: List[Dict[str, Any]]  # 止盈止损计划列表
) -> bool
```

**7.1.1 参数验证**：
- `cl_ord_id`：不能为空
- `plans`：不能为空列表
- 每个plan必须包含`take_profit`或`stop_loss`，以及`amount`
- 验证止损止盈价格合理性

**7.1.2 旧条件单取消**：
- **查询所有条件单**：通过OKX API查询该持仓的所有策略订单
- **取消所有条件单**：取消所有止损和止盈条件单
- **错误处理**：如果取消失败，记录警告但继续创建新条件单

**7.1.3 新条件单创建**：
- **遍历plans**：为每个plan创建条件单
- **止盈条件单**：如果plan包含`take_profit`
- **止损条件单**：如果plan包含`stop_loss`
- **数量转换**：币数量 → 合约张数
- **批量创建**：支持多个止盈止损计划

**7.1.4 交易关系更新**：
- 更新trading_relations表，记录止损止盈价格
- 不更新内存状态（止损止盈不影响持仓状态）

### 7.2 OKX Algo Order

**止损条件单**：
- **触发方式**：价格触发（`slTriggerPxType='last'`）
- **触发价格**：`slTriggerPx`（止损触发价格）
- **执行方式**：市价单（`slOrdPx='-1'`）
- **数量**：指定数量（`sz`）

**止盈条件单**：
- **触发方式**：价格触发（`tpTriggerPxType='last'`）
- **触发价格**：`tpTriggerPx`（止盈触发价格）
- **执行方式**：市价单（`tpOrdPx='-1'`）
- **数量**：指定数量（`sz`）

**条件单类型**：
- **止盈止损单**：`order_type='conditional'`
- **触发条件**：价格达到触发价格时自动执行
- **执行订单**：市价单，立即成交

### 7.3 多止损止盈支持

**支持方式**：
- 通过`plans`参数支持多个止盈止损计划
- 每个plan可以设置不同的触发价格和数量
- 例如：
  ```python
  plans = [
      {"take_profit": 3500.0, "amount": 0.03},  # 第一个止盈
      {"take_profit": 3600.0, "amount": 0.03},  # 第二个止盈
      {"stop_loss": 3000.0, "amount": 0.1}  # 止损
  ]
  ```

**应用场景**：
- 分批止盈：不同价格分批止盈，锁定利润
- 移动止损：调整止损价格，保护利润
- 风险控制：设置多个止损点，降低风险

### 7.4 错误处理

**参数验证错误**：
- 抛出`ValueError`，包含详细错误信息

**条件单取消错误**：
- 记录警告，继续创建新条件单
- 不影响整体流程

**条件单创建错误**：
- 如果部分创建失败，记录错误
- 返回成功创建的数量
- 如果全部失败，抛出`RuntimeError`

## 八、外部平仓处理

### 8.1 handle_external_close_position 方法

**方法签名**：
```python
def handle_external_close_position(
    self,
    pos_id: str,
    cl_ord_id: str,
    close_amount: float,
    close_price: Optional[float] = None,
    is_full_close: bool = False,
    inst_id: Optional[str] = None,
    pos_side: Optional[str] = None,
    u_time: Optional[str] = None
) -> bool
```

**8.1.1 外部平仓检测**：
- **检测来源**：WebSocket持仓消息
- **检测条件**：持仓数量从 >0 变为 0，或数量减少
- **去重机制**：
  1. 通过`position_history`查询是否有相同的`(pos_id, c_time)`记录
  2. 通过`order_history`查询是否有相同的`ord_id`记录
  3. 检查最近30秒内是否有相同`operation_type`且`amount`相近的记录

**8.1.2 clOrdId查找**：
- **查找方式**：`_find_cl_ord_id_by_pos_id()`
- **查找逻辑**：
  1. 从`trading_relations`查询该`pos_id`对应的`cl_ord_id`
  2. 如果找不到，从`position_history`查询关联的`cl_ord_id`
- **验证**：检查找到的`cl_ord_id`是否与内存状态一致

**8.1.3 条件单取消**：
- **查询所有条件单**：通过OKX API查询
- **取消所有条件单**：取消所有止损止盈条件单
- **错误处理**：如果取消失败，记录警告但继续处理

**8.1.4 交易关系更新**：
- **记录平仓操作**：`operation_type='close'`或`'reduce'`
- **关联position_history**：如果找到对应的`position_history_id`，关联记录
- **记录平仓信息**：`close_order_id`、`close_time`、`close_amount`
- **计算盈亏**：如果提供`close_price`，计算盈亏

**8.1.5 盈亏计算**：
- **计算方式**：与平仓功能相同
- **数据来源**：从`trading_relations`查询开仓信息
- **更新记录**：更新`pnl`和`pnl_percentage`字段

### 8.2 外部平仓场景

**手动平仓**：
- 用户在OKX交易所手动平仓
- WebSocket检测到持仓变化
- 系统自动处理，更新记录

**爆仓**：
- 价格触发强平
- WebSocket检测到持仓变为0
- 系统自动处理，记录爆仓信息

**部分平仓**：
- 用户手动部分平仓
- WebSocket检测到持仓减少
- 系统自动处理，更新持仓数量

### 8.3 与WebSocket集成

**集成方式**：
- WebSocket检测到持仓变化
- 调用`TradingManager.handle_external_close_position()`
- 异步处理，避免阻塞WebSocket消息

**处理流程**：
```
WebSocket接收持仓消息
    ↓
检测持仓变化（数量减少或变为0）
    ↓
添加到平仓事件队列
    ↓
异步处理线程处理
    ↓
调用TradingManager.handle_external_close_position()
    ↓
更新交易记录和内存状态
```

### 8.4 错误处理

**去重失败**：
- 如果去重检查失败，记录警告
- 继续处理，避免重复处理

**clOrdId查找失败**：
- 如果找不到对应的clOrdId，记录警告
- 返回False，不更新记录

**条件单取消失败**：
- 记录警告，继续处理
- 不影响交易记录更新

## 九、订单管理

### 9.1 clOrdId生成

**9.1.1 ClOrdIdGenerator设计**：
- **生成器类**：`ClOrdIdGenerator`（静态方法）
- **生成格式**：`YYMMDDHHmm`（10位时间戳）+ 随机字符串（22位）
- **总长度**：32位（符合OKX要求：1-32位）
- **字符集**：大小写字母（a-z, A-Z）+ 数字（0-9）
- **唯一性保证**：
  - 时间戳部分：精确到分钟，保证时间唯一性
  - 随机部分：22位随机字符串，碰撞概率极低
  - 组合：时间戳 + 随机字符串，双重保证唯一性

**9.1.2 唯一性保证**：
- **时间戳部分**：`YYMMDDHHmm`（10位），精确到分钟
- **随机部分**：22位随机字符串，使用`random.choices()`
- **验证方法**：`validate()`方法验证格式是否符合要求
- **使用场景**：所有交易操作（开仓、加仓、减仓、平仓）都使用clOrdId

### 9.2 订单状态追踪

**9.2.1 当前订单ID管理**：
- **内存状态**：`current_cl_ord_id`（当前活跃持仓的clOrdId）
- **设置方法**：`_set_current_cl_ord_id()`（开仓时调用）
- **清除方法**：`_clear_current_cl_ord_id()`（全部平仓时调用）
- **查询方法**：`get_current_cl_ord_id()`、`has_active_position()`

**9.2.2 订单状态更新**：
- **数据来源**：WebSocket订单频道（`OKXOrdersWebSocketClient`）
- **更新方式**：实时接收订单状态变化，更新`order_history`表
- **状态字段**：`state`（filled/partially_filled/canceled等）
- **关联记录**：通过`trading_relations`表关联clOrdId和ordId

### 9.3 订单历史记录

**9.3.1 order_history表**：
- **存储内容**：所有订单的完整信息
- **关键字段**：
  - `ord_id`：OKX订单ID
  - `cl_ord_id`：客户端订单ID
  - `symbol`：交易对
  - `side`：买卖方向（buy/sell）
  - `pos_side`：持仓方向（long/short）
  - `state`：订单状态
  - `acc_fill_sz`：累计成交数量
  - `fill_time`：成交时间
  - `raw_data`：原始API响应（JSONB）

**9.3.2 订单查询**：
- **通过clOrdId查询**：`get_order_status(cl_ord_id)`
- **返回信息**：
  - `ord_ids`：订单ID列表（OKX可能拆单）
  - `orders`：订单详情列表
  - `total_filled`：总成交数量
  - `total_amount`：总订单数量
  - `status`：整体状态（open/closed/partially_filled）

## 十、仓位管理

### 10.1 当前持仓追踪

**10.1.1 trading_relations表**：
- **作用**：记录完整的交易链路
- **关联关系**：`signal_id` → `cl_ord_id` → `ord_id` → `position_history_id`
- **操作类型**：`operation_type`（open/add/reduce/close/set_stop_loss_take_profit）
- **数量记录**：`amount`（每次操作的数量）
- **价格记录**：`price`（每次操作的价格）

**10.1.2 持仓状态查询**：
- **内存查询**：`has_active_position()`、`get_current_cl_ord_id()`
- **数据库查询**：通过`trading_relations`表查询
- **OKX API查询**：`_get_current_position_from_okx()`（实时查询）
- **状态同步**：定期与OKX API同步，修复状态不一致

### 10.2 持仓方向管理

**10.2.1 LONG（做多）**：
- **OKX side**：'buy'
- **OKX posSide**：'long'
- **内存状态**：`current_position_side = 'LONG'`
- **平仓方向**：'sell'（反向平仓）

**10.2.2 SHORT（做空）**：
- **OKX side**：'sell'
- **OKX posSide**：'short'
- **内存状态**：`current_position_side = 'SHORT'`
- **平仓方向**：'buy'（反向平仓）

### 10.3 持仓数量管理

**10.3.1 实时更新**：
- **开仓时**：设置`current_position_amount`（从order_history查询实际成交数量）
- **加仓时**：增加`current_position_amount`
- **减仓时**：减少`current_position_amount`
- **平仓时**：清除`current_position_amount`

**10.3.2 部分平仓支持**：
- **支持场景**：部分平仓、外部部分平仓
- **更新方法**：`_update_position_amount(new_amount)`
- **验证**：如果新数量 <= 0，自动清除内存状态

## 十一、与APIManager集成

### 11.1 API请求提交

**11.1.1 优先级设置**：
- **RequestPriority枚举**：
  - `STOP_LOSS = 1`：止损（最高优先级）
  - `TRADE = 2`：交易（中等优先级）
  - `QUERY = 3`：查询（最低优先级）
- **使用场景**：
  - 交易操作：`RequestPriority.TRADE`
  - 止损止盈：`RequestPriority.STOP_LOSS`
  - 查询操作：`RequestPriority.QUERY`

**11.1.2 请求封装**：
- **APIRequest类**：
  - `priority`：优先级
  - `func`：API函数
  - `args`、`kwargs`：函数参数
  - `callback`：回调函数（可选）
  - `timestamp`：时间戳
- **提交方式**：`submit_request()`（同步调用，内部使用优先级队列）

### 11.2 订单执行

**11.2.1 市价单**：
- **类型**：`ordType='market'`
- **执行方式**：立即以当前市场价格成交
- **使用场景**：开仓、加仓、减仓、平仓
- **价格**：不指定价格，由交易所决定

**11.2.2 限价单**：
- **类型**：`ordType='limit'`
- **执行方式**：指定价格，等待成交
- **使用场景**：挂单（当前系统未使用）

**11.2.3 条件单**：
- **类型**：`order_type='conditional'`（OKX Algo Order）
- **执行方式**：价格触发后自动执行
- **使用场景**：止损止盈
- **触发条件**：`slTriggerPx`、`tpTriggerPx`

### 11.3 错误重试

**重试机制**：
- **自动重试**：APIManager内部实现
- **重试次数**：`API_MAX_RETRIES`（默认3次）
- **重试间隔**：指数退避
- **超时设置**：`API_REQUEST_TIMEOUT`（默认30秒）
- **错误处理**：记录详细错误日志，抛出异常

## 十二、与WebSocket集成

### 12.1 订单状态回调

**集成方式**：
- **WebSocket客户端**：`OKXOrdersWebSocketClient`
- **订阅频道**：订单频道（orders）
- **回调处理**：实时接收订单状态更新，写入`order_history`表
- **去重机制**：通过`(ord_id, u_time)`组合去重

### 12.2 持仓状态回调

**集成方式**：
- **WebSocket客户端**：`OKXOrderWebSocketClient`（持仓频道）
- **订阅频道**：持仓频道（positions）
- **回调处理**：实时接收持仓变化，检测外部平仓
- **去重机制**：通过`(pos_id, u_time)`组合去重

### 12.3 外部平仓检测

**检测流程**：
```
WebSocket接收持仓消息
    ↓
检测持仓变化（数量减少或变为0）
    ↓
添加到平仓事件队列（异步处理）
    ↓
调用TradingManager.handle_external_close_position()
    ↓
更新交易记录和内存状态
```

**检测条件**：
- 持仓数量从 >0 变为 0（全部平仓）
- 持仓数量减少（部分平仓）
- 持仓方向变化（反向开仓）

## 十三、PendingOrderManager 设计

### 13.1 类结构

**核心属性**：
- `db`：数据库连接
- `pending_order_repo`：挂单Repository
- **职责**：管理挂单的创建、查询、取消

**方法列表**：
- `create_pending_order()`：创建挂单
- `get_pending_order()`：查询挂单
- `cancel_pending_order()`：取消挂单
- `get_pending_orders_by_status()`：按状态查询挂单列表

### 13.2 初始化流程

1. **验证数据库连接**：检查数据库连接是否正常
2. **初始化Repository**：创建`PendingOrderRepository`实例
3. **记录日志**：记录初始化成功日志

## 十四、挂单创建

### 14.1 create_pending_order 方法

**方法签名**：
```python
def create_pending_order(
    self,
    symbol: str,
    side: str,
    amount: float,
    trigger_price: float,
    stop_loss_trigger: float,
    take_profit_trigger: float,
    leverage: float,
    signal_id: Optional[int] = None,
    expire_hours: Optional[float] = None
) -> int
```

**14.1.1 参数验证**：
- `symbol`：不能为空，转换为大写
- `side`：必须是LONG或SHORT
- `amount`：必须大于0
- `trigger_price`：必须大于0
- `stop_loss_trigger`：必须大于0
- `take_profit_trigger`：必须大于0
- `leverage`：必须大于0
- `expire_hours`：如果未提供，从配置读取（默认1小时）

**14.1.2 旧挂单取消**：
- **自动取消**：创建新挂单时，自动取消所有待处理的挂单
- **方法**：`cancel_old_pending_orders()`
- **设计考虑**：一次只能有一个待处理的挂单

**14.1.3 挂单记录创建**：
- **插入数据库**：`pending_orders`表
- **状态**：`status='PENDING'`
- **过期时间**：`expired_at = created_at + expire_hours`
- **返回**：挂单ID

### 14.2 挂单数据结构

**pending_orders表字段**：
- `id`：挂单ID（主键）
- `symbol`：币种名称
- `side`：持仓方向（LONG/SHORT）
- `amount`：开仓数量
- `trigger_price`：触发价格
- `stop_loss_trigger`：止损触发价格
- `take_profit_trigger`：止盈触发价格
- `leverage`：杠杆倍数
- `signal_id`：信号ID（可选）
- `status`：状态（PENDING/EXPIRED/FILLED/FAILED/CANCELLED）
- `expired_at`：过期时间
- `triggered_at`：触发时间
- `filled_at`：完成时间
- `error_message`：错误信息
- `cl_ord_id`：开仓成功后的clOrdId

### 14.3 挂单状态

**状态流转**：
```
PENDING（待触发）
    ↓
EXPIRED（过期）或 FILLED（已成交）或 FAILED（失败）或 CANCELLED（已取消）
```

**状态说明**：
- **PENDING**：待触发，等待价格达到触发价格
- **EXPIRED**：已过期，超过过期时间未触发
- **FILLED**：已成交，触发后开仓成功
- **FAILED**：失败，触发后开仓失败
- **CANCELLED**：已取消，手动取消或创建新挂单时自动取消

## 十五、挂单查询

### 15.1 get_pending_order 方法

**方法签名**：
```python
def get_pending_order(self, order_id: int) -> Optional[Dict[str, Any]]
```

**功能**：
- 根据挂单ID查询挂单信息
- 返回挂单字典，包含所有字段
- 如果不存在，返回None

### 15.2 按状态查询

**方法签名**：
```python
def get_pending_orders_by_status(self, status: str) -> list
```

**功能**：
- 根据状态查询挂单列表
- 状态：PENDING/EXPIRED/FILLED/FAILED/CANCELLED
- 按创建时间倒序排列

### 15.3 挂单列表查询

**查询方法**：
- `get_pending_orders_to_check()`：查询待检查的挂单（状态为PENDING且未过期）
- 用于挂单监控服务，检查是否需要触发

## 十六、挂单取消

### 16.1 cancel_pending_order 方法

**方法签名**：
```python
def cancel_pending_order(self, order_id: int) -> bool
```

**功能**：
- 取消指定挂单
- 只能取消状态为PENDING的挂单
- 更新状态为CANCELLED

### 16.2 取消逻辑

**取消场景**：
- **手动取消**：用户主动取消挂单
- **自动取消**：创建新挂单时，自动取消所有待处理的挂单
- **过期取消**：挂单过期后，状态自动变为EXPIRED（不是CANCELLED）

### 16.3 状态更新

**更新字段**：
- `status`：更新为'CANCELLED'
- `updated_at`：更新为当前时间
- **验证**：只能取消状态为PENDING的挂单

## 十七、挂单监控

### 17.1 PendingOrderMonitor

**17.1.1 监控机制**：
- **独立线程**：在后台线程中运行监控循环
- **监控间隔**：每秒检查一次（`check_interval = 1.0`）
- **监控内容**：
  - 检查过期挂单
  - 检查待触发的挂单

**17.1.2 触发检查**：
- **价格获取**：从WebSocket客户端获取实时价格
- **触发条件**：
  - LONG：当前价格 <= 触发价格
  - SHORT：当前价格 >= 触发价格
- **检查顺序**：按创建时间正序，一次只处理一个挂单

**17.1.3 过期检查**：
- **检查方法**：`_check_expired_orders()`
- **标记过期**：调用`mark_expired_orders()`，将过期挂单状态更新为EXPIRED
- **检查频率**：每秒检查一次

### 17.2 自动执行

**17.2.1 价格触发**：
- **触发条件**：价格达到触发价格
- **触发处理**：
  1. 更新状态为PENDING（保持，等待开仓结果）
  2. 记录触发时间（`triggered_at`）
  3. 检查是否有活跃持仓（如果有，取消挂单）

**17.2.2 开仓执行**：
- **调用开仓**：`trading_manager.open_position()`
- **参数传递**：从挂单记录中获取所有参数
- **结果处理**：
  - 成功：更新状态为FILLED，记录`cl_ord_id`和`filled_at`
  - 失败：更新状态为FAILED，记录`error_message`

## 十八、挂单过期机制

### 18.1 过期时间配置

**配置方式**：
- **参数**：`expire_hours`（创建挂单时指定）
- **默认值**：从配置读取（`PENDING_ORDER_EXPIRE_HOURS`，默认1.0小时）
- **计算方式**：`expired_at = created_at + expire_hours`

### 18.2 过期检查

**检查机制**：
- **检查频率**：每秒检查一次（在监控循环中）
- **检查条件**：`status='PENDING' AND expired_at <= NOW()`
- **检查方法**：`_check_expired_orders()`

### 18.3 过期处理

**处理方式**：
- **状态更新**：将状态更新为EXPIRED
- **更新字段**：`status='EXPIRED'`、`updated_at=NOW()`
- **不再触发**：过期后的挂单不再检查触发条件

## 十九、数据模型

### 19.1 trading_relations表

**19.1.1 表结构**：
```sql
CREATE TABLE trading_relations (
    id SERIAL PRIMARY KEY,
    signal_id INTEGER NOT NULL,
    cl_ord_id VARCHAR(100) NOT NULL,
    ord_id VARCHAR(100),
    position_history_id INTEGER,
    operation_type VARCHAR(50) NOT NULL,
    amount NUMERIC(20, 8),
    price NUMERIC(20, 8),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**19.1.2 字段说明**：
- `signal_id`：信号ID（market_signals.id）
- `cl_ord_id`：客户端订单ID（唯一标识一次交易）
- `ord_id`：订单ID（OKX的ordId，可能多个）
- `position_history_id`：仓位历史ID（position_history.id）
- `operation_type`：操作类型（open/add/reduce/close/set_stop_loss_take_profit）
- `amount`：操作数量（币数量）
- `price`：操作价格

### 19.2 pending_order表

**19.2.1 表结构**：
```sql
CREATE TABLE pending_orders (
    id SERIAL PRIMARY KEY,
    symbol VARCHAR(20) NOT NULL,
    side VARCHAR(10) NOT NULL,
    amount NUMERIC(20, 8) NOT NULL,
    trigger_price NUMERIC(20, 8) NOT NULL,
    stop_loss_trigger NUMERIC(20, 8) NOT NULL,
    take_profit_trigger NUMERIC(20, 8) NOT NULL,
    leverage NUMERIC(10, 2) NOT NULL,
    signal_id INTEGER,
    status VARCHAR(20) NOT NULL,
    expired_at TIMESTAMP WITH TIME ZONE NOT NULL,
    triggered_at TIMESTAMP WITH TIME ZONE,
    filled_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    cl_ord_id VARCHAR(100),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**19.2.2 字段说明**：
- `symbol`：币种名称
- `side`：持仓方向（LONG/SHORT）
- `amount`：开仓数量
- `trigger_price`：触发价格
- `stop_loss_trigger`：止损触发价格
- `take_profit_trigger`：止盈触发价格
- `leverage`：杠杆倍数
- `signal_id`：信号ID（可选）
- `status`：状态（PENDING/EXPIRED/FILLED/FAILED/CANCELLED）
- `expired_at`：过期时间
- `triggered_at`：触发时间
- `filled_at`：完成时间
- `error_message`：错误信息
- `cl_ord_id`：开仓成功后的clOrdId

### 19.3 order_history表

**19.3.1 表结构**：
- 由`OrderHistorySyncManager`和`OKXOrdersWebSocketClient`同步
- 存储所有订单的完整信息

**19.3.2 字段说明**：
- `ord_id`：订单ID（OKX的ordId）
- `cl_ord_id`：客户端订单ID
- `symbol`：交易对
- `side`：买卖方向（buy/sell）
- `pos_side`：持仓方向（long/short）
- `state`：订单状态（filled/partially_filled/canceled等）
- `acc_fill_sz`：累计成交数量
- `fill_time`：成交时间
- `raw_data`：原始API响应（JSONB）

## 二十、错误处理

### 20.1 参数验证错误

**处理方式**：
- **抛出异常**：`ValueError`，包含详细错误信息
- **不调用API**：避免无效请求
- **记录日志**：记录参数验证失败的详细信息

### 20.2 API调用错误

**处理方式**：
- **自动重试**：通过APIManager自动重试（最多3次）
- **错误记录**：记录详细错误日志
- **抛出异常**：如果最终失败，抛出`RuntimeError`
- **错误信息**：包含错误代码和错误消息

### 20.3 持仓状态不一致

**处理方式**：
- **兜底检查**：开仓前查询OKX API实际持仓
- **自动修复**：如果内存状态与实际持仓不一致，自动修复
- **清除状态**：如果实际持仓为0，清除内存状态
- **拒绝操作**：如果实际有持仓，拒绝开仓

### 20.4 订单执行失败

**处理方式**：
- **错误记录**：记录详细错误日志
- **状态更新**：更新挂单状态为FAILED（如果是挂单）
- **抛出异常**：抛出`RuntimeError`，包含错误信息
- **不更新内存**：如果订单执行失败，不更新内存状态

### 20.5 错误恢复机制

**恢复策略**：
- **状态同步**：定期与OKX API同步，修复状态不一致
- **自动修复**：检测到状态不一致时，自动修复
- **日志记录**：记录所有错误和修复操作
- **人工介入**：严重错误需要人工介入处理

## 二十一、性能优化

### 21.1 数据库查询优化

**优化措施**：
- **索引优化**：在`cl_ord_id`、`ord_id`、`signal_id`等字段上创建索引
- **查询优化**：使用`LIMIT`限制查询结果数量
- **批量查询**：避免在循环中查询数据库
- **连接池**：使用数据库连接池，提高并发性能

### 21.2 缓存机制

**缓存策略**：
- **内存状态**：使用内存变量缓存当前持仓状态
- **定期同步**：定期与OKX API和数据库同步
- **缓存失效**：状态变化时立即更新缓存

### 21.3 异步处理

**异步场景**：
- **WebSocket回调**：使用队列异步处理，避免阻塞
- **外部平仓处理**：使用独立线程处理，避免阻塞WebSocket消息
- **挂单监控**：使用独立线程监控，不影响主流程

## 二十二、配置说明

### 22.1 交易相关配置

**配置项**：
- `MAX_LEVERAGE`：最大杠杆倍数（默认10）
- `EXCHANGE_API_KEY`：交易所API密钥
- `EXCHANGE_SECRET`：交易所密钥
- `EXCHANGE_PASSPHRASE`：交易所密码短语
- `EXCHANGE_SANDBOX`：是否使用沙箱环境

### 22.2 挂单相关配置

**配置项**：
- `PENDING_ORDER_EXPIRE_HOURS`：挂单过期时长（小时，默认1.0）
- `PENDING_ORDER_CHECK_INTERVAL`：挂单检查间隔（秒，默认1.0）

### 22.3 超时配置

**配置项**：
- `API_REQUEST_TIMEOUT`：API请求超时时间（秒，默认30）
- `API_MAX_RETRIES`：API最大重试次数（默认3）
- `API_RATE_LIMIT`：API限流（每时间窗口的请求数，默认10）
- `API_RATE_WINDOW`：API限流时间窗口（秒，默认2）
