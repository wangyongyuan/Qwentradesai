# 市场检测架构文档

## 一、概述

### 1.1 MarketDetector 职责

MarketDetector是系统的核心分析模块，负责基于技术指标自动识别交易机会。

**主要职责**：
- 实时分析市场数据（K线、技术指标）
- 通过三层过滤机制识别高质量交易信号
- 生成交易信号并保存到数据库
- 记录检测快照，便于后续分析和优化

**设计特点**：
- **三层过滤**：环境层→触发层→确认层，逐层筛选，确保信号质量
- **多维度检测**：6个触发维度，综合判断市场机会
- **多时间框架**：结合15分钟和4小时K线，提高信号准确性
- **智能评分**：基于多个维度计算信号强度和置信度

### 1.2 三层过滤机制总览

**环境层（Filter Layer）**：
- **目的**：判断市场环境和活跃度
- **输出**：市场模式（BULL/BEAR/NEUTRAL）、市场活跃度、多时间框架对齐
- **作用**：过滤不活跃或震荡市场，只关注有趋势的市场

**触发层（Trigger Layer）**：
- **目的**：识别交易信号触发点
- **检测维度**：6个维度（MACD动量转折、EMA交叉、RSI极值、布林带突破、成交量异常、价格形态）
- **作用**：识别潜在交易机会，确定信号方向（LONG/SHORT）

**确认层（Confirm Layer）**：
- **目的**：验证信号质量
- **验证维度**：成交量确认、布林带确认、多时间框架共振
- **作用**：确保信号有足够的市场参与度和波动率

**流程**：
```
环境层过滤 → 如果通过 → 触发层检测 → 如果有触发 → 确认层验证 → 如果确认 → 生成信号
```

### 1.3 设计理念

**质量优先**：
- 宁可错过，不可做错
- 三层过滤确保信号质量
- 只有同时满足多个条件才生成信号

**多维度验证**：
- 不依赖单一指标
- 综合多个技术指标判断
- 多时间框架共振提高准确性

**可配置性**：
- 所有阈值和参数可配置
- 支持动态调整策略
- 配置从数据库读取，无需重启

**可追溯性**：
- 每次检测保存快照
- 记录所有检测细节
- 便于后续分析和优化

## 二、环境层（Filter Layer）

### 2.1 市场模式判断

**判断逻辑**（`_filter_layer`方法）：

**BULL/BEAR/NEUTRAL 判断**：
- **依据**：15分钟K线最新价格 vs EMA55
- **BULL（牛市）**：价格 > EMA55
- **BEAR（熊市）**：价格 < EMA55
- **NEUTRAL（震荡）**：价格 ≈ EMA55

**实现代码**：
```python
price_15m = float(latest_15m['close'])
ema_55 = latest_15m.get('ema_55')

if ema_55 is None:
    market_mode = 'NEUTRAL'
    trend_15m = None
else:
    ema_55 = float(ema_55)
    if price_15m > ema_55:
        market_mode = 'BULL'
        trend_15m = True
    elif price_15m < ema_55:
        market_mode = 'BEAR'
        trend_15m = False
    else:
        market_mode = 'NEUTRAL'
        trend_15m = None
```

**EMA55 趋势判断**：
- **EMA55**：长期趋势指标（55周期指数移动平均线）
- **作用**：判断市场整体趋势方向
- **周期选择**：55周期适合15分钟K线，能够过滤短期波动

**设计考虑**：
- 如果EMA55未计算，无法判断市场模式，返回NEUTRAL
- 价格等于EMA55时，认为市场处于震荡状态

### 2.2 市场活跃度判断

**布林带宽度计算**：
- **数据来源**：最近20根15分钟K线的布林带宽度
- **计算方式**：
  - 提取最近20根K线的`bb_width`字段
  - 计算平均宽度：`avg_bb_width = mean(bb_widths)`
  - 获取当前K线的布林带宽度：`current_bb_width`

**活跃度阈值**：
- **阈值配置**：`DETECTOR_BB_WIDTH_THRESHOLD`（默认0.5）
- **判断逻辑**：`current_bb_width >= avg_bb_width * threshold`
- **含义**：
  - 当前宽度 >= 平均宽度的0.5倍，认为市场活跃
  - 当前宽度 < 平均宽度的0.5倍，认为市场不活跃（震荡市）

**实现代码**：
```python
bb_widths = [
    float(k.get('bb_width', 0) or 0)
    for k in klines_15m[-20:]
    if k.get('bb_width') is not None
]

if bb_widths:
    avg_bb_width = statistics.mean(bb_widths)
    current_bb_width = float(latest_15m.get('bb_width', 0) or 0)
    threshold = settings.DETECTOR_BB_WIDTH_THRESHOLD
    market_active = current_bb_width >= (avg_bb_width * threshold)
else:
    market_active = False
```

**设计考虑**：
- 布林带宽度反映市场波动率
- 宽度小表示市场不活跃（震荡市），不适合趋势交易
- 宽度大表示市场活跃（趋势市），适合交易

### 2.3 多时间框架对齐

**15m趋势判断**：
- **依据**：15分钟K线价格 vs EMA55
- **判断**：`trend_15m = price_15m > ema_55`
- **结果**：True（上涨）、False（下跌）、None（无法判断）

**4h趋势判断**：
- **依据**：4小时K线价格 vs EMA21
- **判断**：`trend_4h = price_4h > ema_21_4h`
- **结果**：True（上涨）、False（下跌）、None（无法判断）

**趋势一致性检查**：
- **对齐判断**：`multi_tf_aligned = (trend_15m == trend_4h)`
- **含义**：
  - 15m和4h趋势一致时，认为多时间框架对齐
  - 对齐时信号更可靠，后续会加分

**实现代码**：
```python
price_4h = float(latest_4h['close'])
ema_21_4h = latest_4h.get('ema_21')

if ema_21_4h is None:
    trend_4h = None
    multi_tf_aligned = False
else:
    ema_21_4h = float(ema_21_4h)
    trend_4h = price_4h > ema_21_4h
    if trend_15m is not None and trend_4h is not None:
        multi_tf_aligned = (trend_15m == trend_4h)
    else:
        multi_tf_aligned = False
```

**设计考虑**：
- 多时间框架对齐提高信号可靠性
- 15m和4h趋势一致时，信号更强
- 如果任一趋势无法判断，认为不对齐

### 2.4 环境层输出

**输出元组**：
```python
(market_mode, market_active, trend_15m, trend_4h, multi_tf_aligned)
```

**字段说明**：
- `market_mode`: 市场模式（'BULL'/'BEAR'/'NEUTRAL'）
- `market_active`: 市场是否活跃（bool）
- `trend_15m`: 15m趋势方向（True/False/None）
- `trend_4h`: 4h趋势方向（True/False/None）
- `multi_tf_aligned`: 多时间框架是否对齐（bool）

**过滤条件**：
- 如果`market_mode == 'NEUTRAL'`，直接退出，不生成信号
- 如果`market_active == False`，直接退出，不生成信号
- 只有`market_mode != 'NEUTRAL'`且`market_active == True`时，才继续触发层检测

## 三、触发层（Trigger Layer）

### 3.1 MACD动量转折检测

**检测方法**（`_check_momentum_turn`）：

**牛市MACD转折逻辑**：
1. **情况1：MACD柱从负转正（金叉）**
   - 条件：`hist_prev <= 0 and hist_latest > 0`
   - 含义：MACD柱从负值转为正值，表示动量转强
   - 触发：返回True

2. **情况2：MACD柱持续增大（动量增强）**
   - 条件：`hist_prev > 0 and hist_latest > hist_prev`
   - 含义：MACD柱持续增大，表示动量持续增强
   - 触发：返回True

**熊市MACD转折逻辑**：
1. **情况1：MACD柱从正转负（死叉）**
   - 条件：`hist_prev >= 0 and hist_latest < 0`
   - 含义：MACD柱从正值转为负值，表示动量转弱
   - 触发：返回True

2. **情况2：MACD柱持续减小（动量减弱）**
   - 条件：`hist_prev < 0 and hist_latest < hist_prev`
   - 含义：MACD柱持续减小，表示动量持续减弱
   - 触发：返回True

**数据要求**：
- 需要至少2根K线数据
- 需要`histogram`字段（MACD柱状图值）
- 如果数据不足，返回False

**实现代码**：
```python
latest = klines_15m[-1]
prev = klines_15m[-2]

hist_latest = float(latest.get('histogram'))
hist_prev = float(prev.get('histogram'))

# 多头模式
if market_mode == 'BULL':
    if hist_prev <= 0 and hist_latest > 0:  # 从负转正
        return True, hist_latest
    if hist_prev > 0 and hist_latest > hist_prev:  # 持续增大
        return True, hist_latest

# 空头模式
elif market_mode == 'BEAR':
    if hist_prev >= 0 and hist_latest < 0:  # 从正转负
        return True, hist_latest
    if hist_prev < 0 and hist_latest < hist_prev:  # 持续减小
        return True, hist_latest
```

### 3.2 RSI超买超卖检测

**检测方法**（`_check_rsi_extreme`）：

**做多RSI上限检查**：
- **配置参数**：`DETECTOR_RSI_LONG_THRESHOLD`（默认80.0）
- **判断逻辑**：`rsi < rsi_long_threshold`
- **含义**：RSI低于80时允许做多，防止极端过热
- **设计考虑**：RSI过高表示市场过热，不适合做多

**做空RSI下限检查**：
- **配置参数**：`DETECTOR_RSI_SHORT_THRESHOLD`（默认20.0）
- **判断逻辑**：`rsi > rsi_short_threshold`
- **含义**：RSI高于20时允许做空，防止极端超卖
- **设计考虑**：RSI过低表示市场超卖，不适合做空

**防止极端过热/超卖**：
- **做多限制**：RSI必须 < 80，避免在极端过热时做多
- **做空限制**：RSI必须 > 20，避免在极端超卖时做空
- **目的**：保护资金，避免在极端市场条件下交易

**实现代码**：
```python
rsi = float(latest.get('rsi_7'))

# 多头模式
if market_mode == 'BULL':
    rsi_long_threshold = settings.DETECTOR_RSI_LONG_THRESHOLD
    if rsi < rsi_long_threshold:
        return True, rsi, position_multiplier

# 空头模式
elif market_mode == 'BEAR':
    rsi_short_threshold = settings.DETECTOR_RSI_SHORT_THRESHOLD
    if rsi > rsi_short_threshold:
        return True, rsi, position_multiplier
```

### 3.3 仓位倍数调整

**做多仓位调整逻辑**：
- **配置参数**：`DETECTOR_RSI_DOUBLE_POSITION_LONG`（默认50.0）
- **判断逻辑**：
  - 如果`rsi < rsi_double`：`position_multiplier = 2.0`（加倍仓位）
  - 否则：`position_multiplier = 1.0`（正常仓位）
- **含义**：RSI越低，做多机会越好，可以适当加大仓位

**做空仓位调整逻辑**：
- **配置参数**：`DETECTOR_RSI_DOUBLE_POSITION_SHORT`（默认50.0）
- **判断逻辑**：
  - 如果`rsi > rsi_double`：`position_multiplier = 2.0`（加倍仓位）
  - 否则：`position_multiplier = 1.0`（正常仓位）
- **含义**：RSI越高，做空机会越好，可以适当加大仓位

**盈亏比优化**：
- **设计理念**：在更好的入场点（RSI极值）加大仓位，提高盈亏比
- **风险控制**：虽然仓位加倍，但仍在可控范围内
- **应用**：仓位倍数会保存到信号中，供交易系统使用

**实现代码**：
```python
# 多头模式
if market_mode == 'BULL':
    rsi_double = settings.DETECTOR_RSI_DOUBLE_POSITION_LONG
    if rsi < rsi_long_threshold:
        if rsi < rsi_double:
            position_multiplier = 2.0  # RSI极低，加倍仓位
        else:
            position_multiplier = 1.0
        return True, rsi, position_multiplier

# 空头模式
elif market_mode == 'BEAR':
    rsi_double = settings.DETECTOR_RSI_DOUBLE_POSITION_SHORT
    if rsi > rsi_short_threshold:
        if rsi > rsi_double:
            position_multiplier = 2.0  # RSI极高，加倍仓位
        else:
            position_multiplier = 1.0
        return True, rsi, position_multiplier
```

### 3.4 触发层输出

**触发维度**：
1. **MACD动量转折**（`momentum_turn`）
2. **EMA交叉**（`ema_cross`）
3. **RSI极值**（`rsi_extreme`）
4. **布林带突破**（`bb_breakout`）
5. **成交量异常**（`volume_surge`）
6. **价格形态**（`price_pattern`）

**其他触发检测**：

**EMA交叉检测**（`_check_ema_cross`）：
- **多头模式**：EMA9上穿EMA21
- **空头模式**：EMA9下穿EMA21
- **判断**：比较最新和前一K线的EMA9和EMA21关系

**布林带突破检测**（`_check_bb_breakout`）：
- **多头模式**：价格突破上轨（`close > bb_upper`）
- **空头模式**：价格跌破下轨（`close < bb_lower`）

**成交量异常检测**（`_check_volume_surge`）：
- **计算**：最近20根K线的平均成交量和标准差
- **阈值**：`avg_volume + DETECTOR_VOLUME_STD_MULTIPLIER * std_volume`
- **判断**：当前成交量 > 阈值

**价格形态检测**（`_check_price_pattern`）：
- **多头模式**：看涨吞没形态（前一根阴线，当前阳线完全吞没）
- **空头模式**：看跌吞没形态（前一根阳线，当前阴线完全吞没）

**触发统计**：
- 统计触发维度数量（`trigger_count`）
- 记录触发因子列表（`trigger_factors`）
- 如果`trigger_count == 0`，不生成信号

## 四、确认层（Confirm Layer）

### 4.1 成交量确认

**成交量统计计算**（`_check_volume_surge`）：
- **数据范围**：最近20根15分钟K线
- **计算步骤**：
  1. 提取最近20根K线的成交量
  2. 计算平均成交量：`avg_volume = mean(volumes)`
  3. 计算标准差：`std_volume = stdev(volumes)`
  4. 获取当前K线成交量：`current_volume`

**标准差倍数阈值**：
- **配置参数**：`DETECTOR_VOLUME_STD_MULTIPLIER`（默认1.5）
- **阈值计算**：`threshold = avg_volume + multiplier * std_volume`
- **判断逻辑**：`current_volume > threshold`

**市场参与度验证**：
- **含义**：成交量异常表示市场参与度高，信号更可靠
- **目的**：确保信号有足够的市场关注度
- **实现**：使用与触发层相同的检测方法（`_check_volume_surge`）

**实现代码**：
```python
volumes = [float(k['volume']) for k in klines_15m[-20:]]
avg_volume = statistics.mean(volumes)
std_volume = statistics.stdev(volumes) if len(volumes) >= 2 else 0

threshold = avg_volume + (settings.DETECTOR_VOLUME_STD_MULTIPLIER * std_volume)
volume_ratio = current_volume / avg_volume if avg_volume > 0 else 0

if current_volume > threshold:
    return True, volume_ratio
```

### 4.2 布林带确认

**布林带宽度计算**：
- **数据范围**：最近20根15分钟K线
- **计算步骤**：
  1. 提取最近20根K线的布林带宽度
  2. 计算平均宽度：`avg_bb_width = mean(bb_widths)`
  3. 获取当前K线布林带宽度：`current_bb_width`
  4. 计算宽度比率：`bb_width_ratio = current_bb_width / avg_bb_width`

**波动率阈值**：
- **配置参数**：`DETECTOR_BB_CONFIRM_THRESHOLD`（默认1.2）
- **判断逻辑**：`bb_width_ratio > threshold`
- **含义**：当前宽度必须 > 平均宽度的1.2倍才认为确认

**市场波动验证**：
- **含义**：布林带宽度扩大表示市场波动率增加，信号更可靠
- **目的**：确保信号发生在波动率足够大的市场环境中
- **设计考虑**：波动率小表示市场不活跃，信号质量差

**实现代码**：
```python
bb_widths = [
    float(k.get('bb_width', 0) or 0)
    for k in klines_15m[-20:]
    if k.get('bb_width') is not None
]

current_bb_width = float(latest.get('bb_width', 0) or 0)

if bb_widths and current_bb_width > 0:
    avg_bb_width = statistics.mean(bb_widths)
    if avg_bb_width > 0:
        bb_width_ratio = current_bb_width / avg_bb_width
        threshold = settings.DETECTOR_BB_CONFIRM_THRESHOLD
        bb_confirm = bb_width_ratio > threshold
```

### 4.3 多时间框架共振

**15m和4h信号对齐**：
- **对齐条件**：15m和4h同时满足触发条件
- **实现方式**：在触发层检测时，同时检查15m和4h的触发条件
- **当前实现**：主要基于15m检测，4h用于趋势对齐（环境层）

**共振加分机制**：
- **配置参数**：`DETECTOR_ENABLE_MULTI_TF`（默认True）
- **加分条件**：`multi_tf_aligned == True`（15m和4h趋势一致）
- **加分值**：在评分计算时加分（见评分机制章节）

**可选开关**：
- **配置项**：`DETECTOR_ENABLE_MULTI_TF`
- **作用**：可以关闭多时间框架共振功能
- **默认值**：True（启用）

**设计考虑**：
- 多时间框架共振提高信号可靠性
- 但会增加信号生成难度，可能错过一些机会
- 可通过配置开关控制

### 4.4 确认层输出

**输出元组**：
```python
(volume_confirm, bb_confirm, volume_ratio, bb_width_ratio)
```

**字段说明**：
- `volume_confirm`: 成交量是否确认（bool）
- `bb_confirm`: 布林带是否确认（bool）
- `volume_ratio`: 成交量比率（当前/平均）
- `bb_width_ratio`: 布林带宽度比率（当前/平均）

**确认条件**：
- 至少有一个确认（`volume_confirm or bb_confirm`）
- 如果两个都不确认，不生成信号
- 两个都确认时，信号质量更高

## 五、信号评分机制

### 5.1 评分规则

**信号强度评分**（`_calculate_signal_strength`）：

**基础分（触发层）**：
- 每个触发维度：+1分
- 触发维度数量：`trigger_count`（0-6分）

**加分项**：
- 多时间框架对齐：+0.5分（`multi_tf_aligned`）
- 成交量确认：+1.0分（`volume_confirm`）
- 布林带确认：+1.0分（`bb_confirm`）

**总分计算**：
```python
score = trigger_count
if multi_tf_aligned:
    score += 0.5
if volume_confirm:
    score += 1.0
if bb_confirm:
    score += 1.0
```

**信号强度等级**：
- `VERY_STRONG`：score >= 4
- `STRONG`：score >= 3
- `MODERATE`：score >= 2
- `WEAK`：score < 2

**置信度评分**（`_calculate_confidence_score`）：

**基础分（触发层）**：
- 每个触发维度：+15分
- 触发维度数量：`trigger_count * 15`（0-90分）

**加分项**：
- 多时间框架对齐：+10分
- 成交量确认：+15分
- 布林带确认：+15分

**总分计算**：
```python
score = trigger_count * 15
if multi_tf_aligned:
    score += 10
if volume_confirm:
    score += 15
if bb_confirm:
    score += 15
```

**分数范围**：0-100分（使用`min(100.0, score)`限制上限）

### 5.2 评分计算

**各项得分权重**：

| 维度 | 信号强度权重 | 置信度权重 | 说明 |
|------|-------------|-----------|------|
| 触发维度数量 | 1.0/维度 | 15/维度 | 基础分，每个触发维度加分 |
| 多时间框架对齐 | 0.5 | 10 | 15m和4h趋势一致 |
| 成交量确认 | 1.0 | 15 | 成交量异常，市场参与度高 |
| 布林带确认 | 1.0 | 15 | 波动率增加，市场活跃 |

**总分范围**：
- **信号强度**：0-8.5分（理论上限：6个触发 + 0.5对齐 + 1.0成交量 + 1.0布林带）
- **置信度**：0-100分（实际上限：90 + 10 + 15 + 15 = 130，但限制为100）

**评分示例**：
- **强信号**：3个触发 + 对齐 + 成交量确认 + 布林带确认
  - 信号强度：3 + 0.5 + 1.0 + 1.0 = 5.5 → VERY_STRONG
  - 置信度：45 + 10 + 15 + 15 = 85分
- **中等信号**：2个触发 + 成交量确认
  - 信号强度：2 + 1.0 = 3.0 → STRONG
  - 置信度：30 + 15 = 45分

### 5.3 信号生成条件

**最低分数阈值**：
- **触发层**：至少1个触发维度（`trigger_count >= 1`）
- **确认层**：至少1个确认（`volume_confirm or bb_confirm`）
- **环境层**：市场模式不为NEUTRAL，且市场活跃

**信号类型确定**：
- **LONG信号**：`market_mode == 'BULL'` → `signal_type = 'LONG'`
- **SHORT信号**：`market_mode == 'BEAR'` → `signal_type = 'SHORT'`
- **信号方向**：由市场模式决定，与触发层检测结果一致

**生成条件总结**：
1. 环境层通过（BULL/BEAR且活跃）
2. 至少1个触发维度
3. 至少1个确认（成交量或布林带）
4. 满足以上条件才生成信号

## 六、数据输入

### 6.1 K线数据获取

**15分钟K线（100根）**：
- **配置参数**：`DETECTOR_KLINE_15M_COUNT`（默认100）
- **获取方法**：`_get_klines('15m', count)`
- **数据来源**：`KlineRepository.get_klines_with_indicators()`
- **用途**：主要分析数据，包含所有触发和确认检测

**4小时K线（60根）**：
- **配置参数**：`DETECTOR_KLINE_4H_COUNT`（默认60）
- **获取方法**：`_get_klines('4h', count)`
- **数据来源**：`KlineRepository.get_klines_with_indicators()`
- **用途**：多时间框架分析，趋势对齐判断

**数据获取流程**：
1. 打开数据库会话
2. 调用Repository获取K线数据（含技术指标）
3. 验证数据是否为空
4. 返回K线数据列表（按时间正序排列）

### 6.2 技术指标要求

**必需指标列表**：

**15分钟K线指标**：
- `ema_9`：EMA9（短期趋势）
- `ema_21`：EMA21（中期趋势）
- `ema_55`：EMA55（长期趋势，用于环境层判断）
- `rsi_7`：RSI7（超买超卖判断）
- `macd_line`：MACD线
- `signal_line`：MACD信号线
- `histogram`：MACD柱状图（用于动量转折检测）
- `bb_upper`：布林带上轨
- `bb_middle`：布林带中轨
- `bb_lower`：布林带下轨
- `bb_width`：布林带宽度（用于活跃度和确认判断）
- `volume`：成交量（用于成交量异常检测）
- `open`、`high`、`low`、`close`：K线基础数据

**4小时K线指标**：
- `ema_21`：EMA21（用于4h趋势判断）
- `close`：收盘价（用于价格比较）

**指标数据验证**：
- 检查指标字段是否存在（`is None`检查）
- 检查指标值是否有效（转换为float）
- 如果关键指标缺失，记录警告并跳过相关检测

### 6.3 数据质量检查

**数据量检查**：
- 15m K线：至少需要2根（用于比较）
- 4h K线：至少需要1根（用于趋势判断）
- 如果数据不足，记录警告并返回None

**数据完整性检查**：
- 检查K线数据是否为空
- 检查关键指标是否存在
- 如果数据不完整，记录警告并跳过检测

**数据时效性检查**：
- 使用最新K线数据进行分析
- 确保数据是最新的（由K线同步保证）

## 七、信号输出

### 7.1 信号数据结构

**返回字典结构**：
```python
{
    'signal_id': int,  # 信号ID（数据库主键）
    'snapshot_id': int,  # 检测快照ID
    'signal_type': str,  # 信号类型（'LONG'/'SHORT'）
    'signal_strength': str,  # 信号强度（'WEAK'/'MODERATE'/'STRONG'/'VERY_STRONG'）
    'confidence_score': float,  # 置信度分数（0-100）
    'price': float,  # 检测时的价格
    'trigger_factors': List[str]  # 触发因子列表
}
```

**signal_type (LONG/SHORT)**：
- `LONG`：做多信号（市场模式为BULL）
- `SHORT`：做空信号（市场模式为BEAR）

**symbol（币种）**：
- 检测的币种名称（如'ETH'、'BTC'）
- 从MarketDetector初始化时传入

**score（评分）**：
- 使用`confidence_score`作为主要评分
- 范围：0-100分

**expire_at（过期时间）**：
- 计算方式：`detected_at + timedelta(hours=DETECTOR_SIGNAL_EXPIRE_HOURS)`
- 默认有效期：4小时（可配置）

**details（详细信息JSON）**：
- 包含所有检测细节
- 保存到`market_signal`表的`trigger_factors`字段（JSON格式）

### 7.2 信号保存

**market_signal表结构**：
- `id`：信号ID（主键）
- `snapshot_id`：检测快照ID（外键）
- `symbol`：币种名称
- `signal_type`：信号类型（LONG/SHORT）
- `detected_at`：检测时间
- `price`：检测时的价格
- `confidence_score`：置信度分数
- `signal_strength`：信号强度
- `position_size_multiplier`：仓位倍数
- `kline_15m_time`：15m K线时间
- `kline_4h_time`：4h K线时间
- `trigger_factors`：触发因子列表（JSON）
- `market_mode`：市场模式
- `multi_tf_aligned`：多时间框架对齐
- `rsi_value`：RSI值
- `macd_histogram`：MACD柱状图值
- `volume_ratio`：成交量比率
- `expired_at`：过期时间

**数据持久化**：
- 使用`_save_signal()`方法保存
- 先保存检测快照（`_save_snapshot()`），获取快照ID
- 再保存交易信号，关联快照ID
- 使用数据库事务，确保数据一致性

### 7.3 信号有效期

**默认有效期（4小时）**：
- **配置参数**：`DETECTOR_SIGNAL_EXPIRE_HOURS`（默认4）
- **计算方式**：`expired_at = detected_at + timedelta(hours=4)`
- **设计考虑**：市场条件变化快，信号有效期不宜过长

**过期处理**：
- 过期信号自动失效，不参与交易
- 交易系统查询信号时，过滤过期信号
- 可以通过数据库查询检查信号是否过期：`expired_at > NOW()`

## 八、检测流程

### 8.1 触发条件

**K线同步完成触发**：
- **触发时机**：15分钟K线同步完成后
- **实现位置**：`KlineSyncManager._fetch_and_save_klines()`
- **触发代码**：
  ```python
  if timeframe == '15m' and self.market_detector:
      try:
          self.market_detector.detect()
      except Exception as e:
          logger.error(f"触发市场检测失败: {e}", exc_info=True)
  ```
- **设计考虑**：确保使用最新K线数据，检测结果更准确

**手动触发**：
- **触发方式**：通过API接口调用`detect()`方法
- **API端点**：`POST /market-detector/detect`
- **用途**：测试、调试、手动分析

### 8.2 完整检测流程

**数据获取阶段**：
1. 从配置读取K线数量（15m: 100根，4h: 60根）
2. 调用`_get_klines()`获取15m和4h K线数据
3. 验证数据是否为空
4. 提取最新K线信息（价格、时间等）

**环境层过滤阶段**：
1. 调用`_filter_layer()`进行环境层过滤
2. 判断市场模式（BULL/BEAR/NEUTRAL）
3. 判断市场活跃度
4. 判断多时间框架对齐
5. 如果NEUTRAL或不活跃，保存快照并退出

**触发层检测阶段**：
1. 检测6个触发维度：
   - `_check_momentum_turn()`：MACD动量转折
   - `_check_ema_cross()`：EMA交叉
   - `_check_rsi_extreme()`：RSI极值
   - `_check_bb_breakout()`：布林带突破
   - `_check_volume_surge()`：成交量异常
   - `_check_price_pattern()`：价格形态
2. 统计触发维度数量
3. 记录触发因子列表
4. 如果无任何触发，保存快照并退出

**确认层验证阶段**：
1. 调用`_confirmation_layer()`进行确认层验证
2. 成交量确认（使用`_check_volume_surge()`）
3. 布林带确认（计算宽度比率）
4. 如果无任何确认，保存快照并退出

**评分计算阶段**：
1. 确定信号方向（LONG/SHORT）
2. 调用`_calculate_signal_strength()`计算信号强度
3. 调用`_calculate_confidence_score()`计算置信度
4. 确定仓位倍数（基于RSI极值）

**信号生成阶段**：
1. 保存检测快照（`_save_snapshot()`）
2. 保存交易信号（`_save_signal()`）
3. 返回信号信息字典

### 8.3 流程时序图

```
开始检测
    ↓
获取K线数据（15m×100, 4h×60）
    ↓
环境层过滤
    ├─ 市场模式判断
    ├─ 市场活跃度判断
    └─ 多时间框架对齐判断
    ↓
[如果NEUTRAL或不活跃] → 保存快照 → 退出
    ↓
触发层检测（6个维度）
    ├─ MACD动量转折
    ├─ EMA交叉
    ├─ RSI极值
    ├─ 布林带突破
    ├─ 成交量异常
    └─ 价格形态
    ↓
[如果无任何触发] → 保存快照 → 退出
    ↓
确认层验证
    ├─ 成交量确认
    └─ 布林带确认
    ↓
[如果无任何确认] → 保存快照 → 退出
    ↓
评分计算
    ├─ 信号强度计算
    └─ 置信度计算
    ↓
保存检测快照
    ↓
保存交易信号
    ↓
返回信号信息
```

## 九、配置参数

### 9.1 环境层参数

**DETECTOR_EMA_TREND_PERIOD**：
- **类型**：int
- **默认值**：55
- **说明**：用于趋势判断的EMA周期（环境层）
- **用途**：判断15m趋势方向（价格 vs EMA55）

**DETECTOR_BB_WIDTH_THRESHOLD**：
- **类型**：float
- **默认值**：0.5
- **说明**：布林带宽度阈值（相对于20根平均值的倍数）
- **用途**：判断市场活跃度，低于此值认为市场不活跃
- **计算公式**：`current_bb_width >= avg_bb_width * threshold`

### 9.2 触发层参数

**DETECTOR_RSI_LONG_THRESHOLD**：
- **类型**：float
- **默认值**：80.0
- **说明**：做多信号RSI上限（RSI低于此值才允许做多）
- **用途**：防止极端过热时做多

**DETECTOR_RSI_SHORT_THRESHOLD**：
- **类型**：float
- **默认值**：20.0
- **说明**：做空信号RSI下限（RSI高于此值才允许做空）
- **用途**：防止极端超卖时做空

**DETECTOR_RSI_DOUBLE_POSITION_LONG**：
- **类型**：float
- **默认值**：50.0
- **说明**：做多时RSI低于此值加倍仓位
- **用途**：在更好的入场点（RSI极低）加大仓位，提高盈亏比

**DETECTOR_RSI_DOUBLE_POSITION_SHORT**：
- **类型**：float
- **默认值**：50.0
- **说明**：做空时RSI高于此值加倍仓位
- **用途**：在更好的入场点（RSI极高）加大仓位，提高盈亏比

### 9.3 确认层参数

**DETECTOR_VOLUME_STD_MULTIPLIER**：
- **类型**：float
- **默认值**：1.5
- **说明**：成交量确认阈值（平均值 + 此倍数 × 标准差）
- **用途**：判断成交量是否异常，降低此值可增加信号数量
- **计算公式**：`threshold = avg_volume + multiplier * std_volume`

**DETECTOR_BB_CONFIRM_THRESHOLD**：
- **类型**：float
- **默认值**：1.2
- **说明**：布林带确认阈值（当前宽度必须 > 平均宽度的此倍数才认为确认）
- **用途**：判断市场波动率是否足够大
- **计算公式**：`bb_width_ratio > threshold`

### 9.4 数据量参数

**DETECTOR_KLINE_15M_COUNT**：
- **类型**：int
- **默认值**：100
- **说明**：使用的15分钟K线数量
- **用途**：获取足够的历史数据进行分析

**DETECTOR_KLINE_4H_COUNT**：
- **类型**：int
- **默认值**：60
- **说明**：使用的4小时K线数量
- **用途**：获取足够的历史数据进行多时间框架分析

### 9.5 其他参数

**DETECTOR_ENABLE_MULTI_TF**：
- **类型**：bool
- **默认值**：True
- **说明**：是否启用多时间框架确认（15m和4h共振加分）
- **用途**：可以关闭多时间框架共振功能，降低信号生成难度

**DETECTOR_SIGNAL_EXPIRE_HOURS**：
- **类型**：int
- **默认值**：4
- **说明**：信号有效期（小时），超过此时间信号自动过期
- **用途**：控制信号有效期，过期信号不参与交易

## 十、与K线同步的集成

### 10.1 集成方式

**MarketDetector注入**：
- **注入位置**：`KlineSyncManager.__init__()`
- **注入方式**：通过构造函数参数传入（可选）
- **代码**：
  ```python
  def __init__(self, api_manager: APIManager, symbol: str, market_detector=None):
      self.market_detector = market_detector  # 可选
  ```

**触发时机**：
- **触发位置**：`KlineSyncManager._fetch_and_save_klines()`
- **触发条件**：`timeframe == '15m' and self.market_detector is not None`
- **触发代码**：
  ```python
  if timeframe == '15m' and self.market_detector:
      try:
          self.market_detector.detect()
      except Exception as e:
          logger.error(f"触发市场检测失败: {e}", exc_info=True)
  ```

**初始化流程**：
1. 在`main.py`中为指定币种创建MarketDetector
2. 在创建KlineSyncManager时传入MarketDetector
3. 15分钟K线更新时自动触发检测

### 10.2 性能考虑

**异步检测**：
- **当前实现**：同步检测（在K线同步线程中直接调用）
- **影响**：检测时间较长时，可能影响K线同步速度
- **优化建议**：可以考虑异步检测（使用队列或线程池）

**检测频率控制**：
- **当前频率**：每15分钟检测一次（15m K线收盘时）
- **控制方式**：通过K线同步频率自然控制
- **设计考虑**：15分钟检测一次，既能及时捕捉机会，又不会过于频繁

**错误隔离**：
- 检测失败不影响K线同步
- 使用try-except包裹检测调用
- 记录错误日志，继续K线同步流程

## 十一、错误处理

### 11.1 数据不足处理

**K线数据不足**：
- **检查**：`if not klines_15m or not klines_4h`
- **处理**：记录警告日志，返回None
- **原因**：可能是系统刚启动，历史数据还未同步完成

**K线数量不足**：
- **检查**：某些检测需要至少2根K线（如MACD动量转折）
- **处理**：返回False，不触发该维度
- **影响**：不影响其他维度的检测

### 11.2 指标缺失处理

**关键指标缺失**：
- **EMA55缺失**：无法判断市场模式，返回NEUTRAL
- **RSI缺失**：RSI极值检测返回False
- **MACD缺失**：MACD动量转折检测返回False
- **布林带缺失**：布林带相关检测返回False

**处理方式**：
- 检查指标是否存在（`is None`检查）
- 如果缺失，记录警告日志
- 跳过相关检测，不影响其他检测

### 11.3 异常情况处理

**数据库异常**：
- **保存快照失败**：记录错误日志，返回None
- **保存信号失败**：记录错误日志，返回None
- **处理方式**：使用try-except包裹，确保异常不传播

**计算异常**：
- **类型转换异常**：使用try-except包裹，返回默认值
- **统计计算异常**：检查数据量，至少需要2个数据点
- **处理方式**：记录警告日志，跳过相关计算

### 11.4 日志记录

**日志级别**：
- **DEBUG**：详细的检测过程（触发条件、计算结果等）
- **INFO**：检测结果（信号生成、快照保存等）
- **WARNING**：数据不足、指标缺失等警告
- **ERROR**：检测失败、保存失败等错误（包含完整堆栈）

**日志内容**：
- 检测开始和结束
- 环境层、触发层、确认层的检测结果
- 信号生成详情（类型、强度、置信度等）
- 错误和异常信息

## 十二、性能优化

### 12.1 数据缓存

**K线数据缓存**：
- **当前实现**：每次检测都从数据库查询
- **优化建议**：可以缓存最近查询的K线数据
- **考虑**：K线数据更新频繁，缓存时间不宜过长

**指标计算缓存**：
- **当前实现**：指标在K线同步时计算，检测时直接使用
- **优势**：避免重复计算，提高检测速度

### 12.2 计算优化

**统计计算优化**：
- 使用Python标准库`statistics`模块
- 批量计算平均值和标准差，避免循环计算
- 只计算需要的统计量

**条件判断优化**：
- 提前退出：环境层不通过时立即退出
- 短路求值：使用`and`/`or`短路，避免不必要的计算
- 减少重复计算：缓存中间结果

### 12.3 数据库查询优化

**查询优化**：
- 使用`LIMIT`限制查询数量
- 使用索引字段查询（symbol, time）
- 只查询需要的字段（通过Repository方法控制）

**批量操作**：
- 快照和信号分别保存，使用独立事务
- 减少数据库交互次数
- 使用参数化查询，提高性能

**连接管理**：
- 使用数据库连接池
- 及时关闭会话，释放连接
- 使用上下文管理器（with语句）确保资源释放

